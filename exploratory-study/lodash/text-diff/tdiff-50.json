Comparing files LODASH\RD\50.js and LODASH\RD\ORIGINAL.JS
***** LODASH\RD\50.js
 1904:          }
 1905:          function baseKeysIn(object) {
***** LODASH\RD\ORIGINAL.JS
 1904:          }
 1905:          /**
 1906:       * The base implementation of `_.keysIn` which doesn't skip the constructor
 1907:       * property of prototypes or treat sparse arrays as dense.
 1908:       *
 1909:       * @private
 1910:       * @param {Object} object The object to query.
 1911:       * @returns {Array} Returns the array of property names.
 1912:       */
 1913:          function baseKeysIn(object) {
*****

***** LODASH\RD\50.js
 2214:          };
 2215:          function baseSlice(array, start, end) {
***** LODASH\RD\ORIGINAL.JS
 2222:          };
 2223:          /**
 2224:       * The base implementation of `_.slice` without an iteratee call guard.
 2225:       *
 2226:       * @private
 2227:       * @param {Array} array The array to slice.
 2228:       * @param {number} [start=0] The start position.
 2229:       * @param {number} [end=array.length] The end position.
 2230:       * @returns {Array} Returns the slice of `array`.
 2231:       */
 2232:          function baseSlice(array, start, end) {
*****

***** LODASH\RD\50.js
 2736:                  case 3:
 2737:                  case 4:
***** LODASH\RD\ORIGINAL.JS
 2753:                  case 3:
 2754:                      return new Ctor(args[0], args[1], args[2]);
 2755:                  case 4:
*****

***** LODASH\RD\50.js
 2767:                      if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
 2768:                      }
***** LODASH\RD\ORIGINAL.JS
 2785:                      if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
 2786:                          wrapper = new LodashWrapper([], true);
 2787:                      }
*****

***** LODASH\RD\50.js
 4285:          }
 4286:          var pullAt = restParam(function (array, indexes) {
 4287:              indexes = arrayMap(baseFlatten(indexes), String);
 4288:              var result = baseAt(array, indexes);
 4289:              basePullAt(array, indexes.sort(compareAscending));
 4290:              return result;
 4291:          });
 4292:          /**
 4293:       * Removes all elements from `array` that `predicate` returns truthy for
 4294:       * and returns an array of the removed elements. The predicate is invoked with
 4295:       * three arguments: (value, index, array).
 4296:       *
 4297:       * **Note:** Unlike `_.filter`, this method mutates `array`.
 4298:       *
***** LODASH\RD\ORIGINAL.JS
 4304:          }
 4305:          /**
 4306:       * Removes elements from `array` corresponding to `indexes` and returns an
 4307:       * array of removed elements.
 4308:       *
 4309:       * **Note:** Unlike `_.at`, this method mutates `array`.
 4310:       *
*****

***** LODASH\RD\50.js
 4302:       * @param {Array} array The array to modify.
 4303:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 4304:       * @returns {Array} Returns the new array of removed elements.
***** LODASH\RD\ORIGINAL.JS
 4314:       * @param {Array} array The array to modify.
 4315:       * @param {...(number|number[])} [indexes] The indexes of elements to remove,
 4316:       *  specified individually or in arrays.
 4317:       * @returns {Array} Returns the new array of removed elements.
*****

***** LODASH\RD\50.js
 4306:       *
 4307:       * var array = [1, 2, 3, 4];
 4308:       * var evens = _.remove(array, function(n) {
 4309:       *   return n % 2 == 0;
 4310:       * });
 4311:       *
***** LODASH\RD\ORIGINAL.JS
 4319:       *
 4320:       * var array = [5, 10, 15, 20];
 4321:       * var evens = _.pullAt(array, 1, 3);
 4322:       *
*****

***** LODASH\RD\50.js
 4312:       * console.log(array);
 4313:       * // => [1, 3]
 4314:       *
***** LODASH\RD\ORIGINAL.JS
 4323:       * console.log(array);
 4324:       * // => [5, 15]
 4325:       *
*****

***** LODASH\RD\50.js
 4315:       * console.log(evens);
 4316:       * // => [2, 4]
 4317:       */
 4318:          function remove(array, predicate) {
 4319:              var result = [];
 4320:              if (!(array && array.length)) {
 4321:                  return result;
 4322:              }
 4323:              var index = -1, indexes = [], length = array.length;
 4324:              predicate = getIteratee(predicate);
 4325:              while (++index < length) {
 4326:                  var value = array[index];
 4327:                  if (predicate(value, index, array)) {
 4328:                      result.push(value);
 4329:                      indexes.push(index);
 4330:                  }
 4331:              }
 4332:              basePullAt(array, indexes);
 4333:              return result;
 4334:          }
 4335:          /**
 4336:       * Gets all but the first element of `array`.
 4337:       *
***** LODASH\RD\ORIGINAL.JS
 4326:       * console.log(evens);
 4327:       * // => [10, 20]
 4328:       */
 4329:          var pullAt = restParam(function (array, indexes) {
 4330:              indexes = arrayMap(baseFlatten(indexes), String);
 4331:              var result = baseAt(array, indexes);
 4332:              basePullAt(array, indexes.sort(compareAscending));
 4333:              return result;
 4334:          });
 4335:          /**
 4336:       * Removes all elements from `array` that `predicate` returns truthy for
 4337:       * and returns an array of the removed elements. The predicate is invoked with
 4338:       * three arguments: (value, index, array).
 4339:       *
 4340:       * **Note:** Unlike `_.filter`, this method mutates `array`.
 4341:       *
*****

***** LODASH\RD\50.js
 4340:       * @category Array
 4341:       * @param {Array} array The array to query.
 4342:       * @returns {Array} Returns the slice of `array`.
 4343:       * @example
***** LODASH\RD\ORIGINAL.JS
 4344:       * @category Array
 4345:       * @param {Array} array The array to modify.
 4346:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 4347:       * @returns {Array} Returns the new array of removed elements.
 4348:       * @example
*****

***** LODASH\RD\50.js
 4344:       *
 4345:       * _.rest([1, 2, 3]);
 4346:       * // => [2, 3]
 4347:       */
 4348:          function rest(array) {
 4349:              return drop(array, 1);
 4350:          }
***** LODASH\RD\ORIGINAL.JS
 4349:       *
 4350:       * var array = [1, 2, 3, 4];
 4351:       * var evens = _.remove(array, function(n) {
 4352:       *   return n % 2 == 0;
 4353:       * });
 4354:       *
 4355:       * console.log(array);
 4356:       * // => [1, 3]
 4357:       *
 4358:       * console.log(evens);
 4359:       * // => [2, 4]
 4360:       */
 4361:          function remove(array, predicate) {
 4362:              var result = [];
 4363:              if (!(array && array.length)) {
 4364:                  return result;
 4365:              }
 4366:              var index = -1, indexes = [], length = array.length;
 4367:              predicate = getIteratee(predicate);
 4368:              while (++index < length) {
 4369:                  var value = array[index];
 4370:                  if (predicate(value, index, array)) {
 4371:                      result.push(value);
 4372:                      indexes.push(index);
 4373:                  }
 4374:              }
 4375:              basePullAt(array, indexes);
 4376:              return result;
 4377:          }
*****

***** LODASH\RD\50.js
 4351:          /**
 4352:       * Creates a slice of `array` from `start` up to, but not including, `end`.
 4353:       *
 4354:       * **Note:** This method is used instead of `Array#slice` to ensure dense
 4355:       * arrays are returned.
 4356:       *
***** LODASH\RD\ORIGINAL.JS
 4378:          /**
 4379:       * Gets all but the first element of `array`.
 4380:       *
*****

***** LODASH\RD\50.js
 4359:       * @category Array
 4360:       * @param {Array} array The array to slice.
 4361:       * @param {number} [start=0] The start position.
 4362:       * @param {number} [end=array.length] The end position.
 4363:       * @returns {Array} Returns the slice of `array`.
 4364:       */
 4365:          function slice(array, start, end) {
 4366:              var length = array ? array.length : 0;
 4367:              if (!length) {
 4368:                  return [];
 4369:              }
 4370:              if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
 4371:                  start = 0;
 4372:                  end = length;
 4373:              }
 4374:              return baseSlice(array, start, end);
 4375:          }
***** LODASH\RD\ORIGINAL.JS
 4383:       * @category Array
 4384:       * @param {Array} array The array to query.
 4385:       * @returns {Array} Returns the slice of `array`.
 4386:       * @example
 4387:       *
 4388:       * _.rest([1, 2, 3]);
 4389:       * // => [2, 3]
 4390:       */
 4391:          function rest(array) {
 4392:              return drop(array, 1);
 4393:          }
*****

***** LODASH\RD\50.js
 4376:          /**
 4377:       * Uses a binary search to determine the lowest index at which `value` should
 4378:       * be inserted into `array` in order to maintain its sort order.
 4379:       *
***** LODASH\RD\ORIGINAL.JS
 4394:          /**
 4395:       * Creates a slice of `array` from `start` up to, but not including, `end`.
 4396:       *
 4397:       * **Note:** This method is used instead of `Array#slice` to ensure dense
 4398:       * arrays are returned.
 4399:       *
*****

***** LODASH\RD\50.js
 4382:       * @category Array
 4383:       * @param {Array} array The sorted array to inspect.
 4384:       * @param {*} value The value to evaluate.
 4385:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
 4386:       * @example
 4387:       *
 4388:       * _.sortedIndex([30, 50], 40);
 4389:       * // => 1
 4390:       *
 4391:       * _.sortedIndex([4, 5], 4);
 4392:       * // => 0
 4393:       */
 4394:          function sortedIndex(array, value) {
 4395:              return binaryIndex(array, value);
 4396:          }
***** LODASH\RD\ORIGINAL.JS
 4402:       * @category Array
 4403:       * @param {Array} array The array to slice.
 4404:       * @param {number} [start=0] The start position.
 4405:       * @param {number} [end=array.length] The end position.
 4406:       * @returns {Array} Returns the slice of `array`.
 4407:       */
 4408:          function slice(array, start, end) {
 4409:              var length = array ? array.length : 0;
 4410:              if (!length) {
 4411:                  return [];
 4412:              }
 4413:              if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
 4414:                  start = 0;
 4415:                  end = length;
 4416:              }
 4417:              return baseSlice(array, start, end);
 4418:          }
*****

***** LODASH\RD\50.js
 4397:          /**
 4398:       * This method is like `_.sortedIndex` except that it accepts `iteratee`
 4399:       * which is invoked for `value` and each element of `array` to compute their
 4400:       * sort ranking. The iteratee is invoked with one argument: (value).
 4401:       *
***** LODASH\RD\ORIGINAL.JS
 4419:          /**
 4420:       * Uses a binary search to determine the lowest index at which `value` should
 4421:       * be inserted into `array` in order to maintain its sort order.
 4422:       *
*****

***** LODASH\RD\50.js
 4406:       * @param {*} value The value to evaluate.
 4407:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4408:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
***** LODASH\RD\ORIGINAL.JS
 4427:       * @param {*} value The value to evaluate.
 4428:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
*****

***** LODASH\RD\50.js
 4410:       *
 4411:       * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
 4412:       *
 4413:       * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
 4414:       * // => 1
***** LODASH\RD\ORIGINAL.JS
 4430:       *
 4431:       * _.sortedIndex([30, 50], 40);
 4432:       * // => 1
*****

***** LODASH\RD\50.js
 4415:       *
 4416:       * // using the `_.property` callback shorthand
 4417:       * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 4418:       * // => 0
***** LODASH\RD\ORIGINAL.JS
 4433:       *
 4434:       * _.sortedIndex([4, 5], 4);
 4435:       * // => 0
*****

***** LODASH\RD\50.js
 4419:       */
 4420:          function sortedIndexBy(array, value, iteratee) {
 4421:              return binaryIndexBy(array, value, getIteratee(iteratee));
 4422:          }
***** LODASH\RD\ORIGINAL.JS
 4436:       */
 4437:          function sortedIndex(array, value) {
 4438:              return binaryIndex(array, value);
 4439:          }
*****

***** LODASH\RD\50.js
 4423:          /**
 4424:       * This method is like `_.sortedIndex` except that it returns the highest
 4425:       * index at which `value` should be inserted into `array` in order to
 4426:       * maintain its sort order.
 4427:       *
***** LODASH\RD\ORIGINAL.JS
 4440:          /**
 4441:       * This method is like `_.sortedIndex` except that it accepts `iteratee`
 4442:       * which is invoked for `value` and each element of `array` to compute their
 4443:       * sort ranking. The iteratee is invoked with one argument: (value).
 4444:       *
*****

***** LODASH\RD\50.js
 4432:       * @param {*} value The value to evaluate.
 4433:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
***** LODASH\RD\ORIGINAL.JS
 4449:       * @param {*} value The value to evaluate.
 4450:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4451:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
*****

***** LODASH\RD\50.js
 4435:       *
 4436:       * _.sortedLastIndex([4, 5], 4);
 4437:       * // => 1
 4438:       */
 4439:          function sortedLastIndex(array, value) {
 4440:              return binaryIndex(array, value, true);
 4441:          }
***** LODASH\RD\ORIGINAL.JS
 4453:       *
 4454:       * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
 4455:       *
 4456:       * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
 4457:       * // => 1
 4458:       *
 4459:       * // using the `_.property` callback shorthand
 4460:       * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 4461:       * // => 0
 4462:       */
 4463:          function sortedIndexBy(array, value, iteratee) {
 4464:              return binaryIndexBy(array, value, getIteratee(iteratee));
 4465:          }
*****

***** LODASH\RD\50.js
 4442:          /**
 4443:       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 4444:       * which is invoked for `value` and each element of `array` to compute their
 4445:       * sort ranking. The iteratee is invoked with one argument: (value).
 4446:       *
***** LODASH\RD\ORIGINAL.JS
 4466:          /**
 4467:       * This method is like `_.sortedIndex` except that it returns the highest
 4468:       * index at which `value` should be inserted into `array` in order to
 4469:       * maintain its sort order.
 4470:       *
*****

***** LODASH\RD\50.js
 4451:       * @param {*} value The value to evaluate.
 4452:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4453:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
***** LODASH\RD\ORIGINAL.JS
 4475:       * @param {*} value The value to evaluate.
 4476:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
*****

***** LODASH\RD\50.js
 4455:       *
 4456:       * // using the `_.property` callback shorthand
 4457:       * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 4458:       * // => 1
***** LODASH\RD\ORIGINAL.JS
 4478:       *
 4479:       * _.sortedLastIndex([4, 5], 4);
 4480:       * // => 1
*****

***** LODASH\RD\50.js
 4459:       */
 4460:          function sortedLastIndexBy(array, value, iteratee) {
 4461:              return binaryIndexBy(array, value, getIteratee(iteratee), true);
 4462:          }
***** LODASH\RD\ORIGINAL.JS
 4481:       */
 4482:          function sortedLastIndex(array, value) {
 4483:              return binaryIndex(array, value, true);
 4484:          }
*****

***** LODASH\RD\50.js
 4463:          /**
 4464:       * Creates a slice of `array` with `n` elements taken from the beginning.
 4465:       *
***** LODASH\RD\ORIGINAL.JS
 4485:          /**
 4486:       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 4487:       * which is invoked for `value` and each element of `array` to compute their
 4488:       * sort ranking. The iteratee is invoked with one argument: (value).
 4489:       *
*****

***** LODASH\RD\50.js
 4468:       * @category Array
 4469:       * @param {Array} array The array to query.
 4470:       * @param {number} [n=1] The number of elements to take.
 4471:       * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
 4472:       * @returns {Array} Returns the slice of `array`.
 4473:       * @example
***** LODASH\RD\ORIGINAL.JS
 4492:       * @category Array
 4493:       * @param {Array} array The sorted array to inspect.
 4494:       * @param {*} value The value to evaluate.
 4495:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4496:       * @returns {number} Returns the index at which `value` should be inserted into `array`.
 4497:       * @example
*****

***** LODASH\RD\50.js
 4474:       *
 4475:       * _.take([1, 2, 3]);
 4476:       * // => [1]
 4477:       *
 4478:       * _.take([1, 2, 3], 2);
 4479:       * // => [1, 2]
 4480:       *
 4481:       * _.take([1, 2, 3], 5);
 4482:       * // => [1, 2, 3]
 4483:       *
 4484:       * _.take([1, 2, 3], 0);
 4485:       * // => []
 4486:       */
 4487:          function take(array, n, guard) {
 4488:              if (!(array && array.length)) {
 4489:                  return [];
 4490:              }
 4491:              n = guard || n == null ? 1 : n;
 4492:              return baseSlice(array, 0, n < 0 ? 0 : n);
 4493:          }
***** LODASH\RD\ORIGINAL.JS
 4498:       *
 4499:       * // using the `_.property` callback shorthand
 4500:       * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 4501:       * // => 1
 4502:       */
 4503:          function sortedLastIndexBy(array, value, iteratee) {
 4504:              return binaryIndexBy(array, value, getIteratee(iteratee), true);
 4505:          }
*****

***** LODASH\RD\50.js
 4494:          /**
 4495:       * Creates a slice of `array` with `n` elements taken from the end.
 4496:       *
***** LODASH\RD\ORIGINAL.JS
 4506:          /**
 4507:       * Creates a slice of `array` with `n` elements taken from the beginning.
 4508:       *
*****

***** LODASH\RD\50.js
 4505:       *
 4506:       * _.takeRight([1, 2, 3]);
 4507:       * // => [3]
 4508:       *
 4509:       * _.takeRight([1, 2, 3], 2);
 4510:       * // => [2, 3]
 4511:       *
 4512:       * _.takeRight([1, 2, 3], 5);
 4513:       * // => [1, 2, 3]
***** LODASH\RD\ORIGINAL.JS
 4517:       *
 4518:       * _.take([1, 2, 3]);
 4519:       * // => [1]
 4520:       *
 4521:       * _.take([1, 2, 3], 2);
 4522:       * // => [1, 2]
 4523:       *
 4524:       * _.take([1, 2, 3], 5);
 4525:       * // => [1, 2, 3]
*****

***** LODASH\RD\50.js
 4514:       *
 4515:       * _.takeRight([1, 2, 3], 0);
 4516:       * // => []
***** LODASH\RD\ORIGINAL.JS
 4526:       *
 4527:       * _.take([1, 2, 3], 0);
 4528:       * // => []
*****

***** LODASH\RD\50.js
 4517:       */
 4518:          function takeRight(array, n, guard) {
 4519:              var length = array ? array.length : 0;
 4520:              if (!length) {
 4521:                  return [];
***** LODASH\RD\ORIGINAL.JS
 4529:       */
 4530:          function take(array, n, guard) {
 4531:              if (!(array && array.length)) {
 4532:                  return [];
*****

***** LODASH\RD\50.js
 4522:              }
 4523:              n = guard || n == null ? 1 : toInteger(n);
 4524:              n = length - n;
 4525:              return baseSlice(array, n < 0 ? 0 : n);
 4526:          }
***** LODASH\RD\ORIGINAL.JS
 4533:              }
 4534:              n = guard || n == null ? 1 : n;
 4535:              return baseSlice(array, 0, n < 0 ? 0 : n);
 4536:          }
*****

***** LODASH\RD\50.js
 4527:          /**
 4528:       * Creates a slice of `array` with elements taken from the end. Elements are
 4529:       * taken until `predicate` returns falsey. The predicate is invoked with three
 4530:       * arguments: (value, index, array).
 4531:       *
***** LODASH\RD\ORIGINAL.JS
 4537:          /**
 4538:       * Creates a slice of `array` with `n` elements taken from the end.
 4539:       *
*****

***** LODASH\RD\50.js
 4535:       * @param {Array} array The array to query.
 4536:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 4537:       * @returns {Array} Returns the slice of `array`.
***** LODASH\RD\ORIGINAL.JS
 4543:       * @param {Array} array The array to query.
 4544:       * @param {number} [n=1] The number of elements to take.
 4545:       * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
 4546:       * @returns {Array} Returns the slice of `array`.
*****

***** LODASH\RD\50.js
 4539:       *
 4540:       * var resolve = _.partial(_.map, _, 'user');
 4541:       *
 4542:       * var users = [
 4543:       *   { 'user': 'barney',  'active': true },
 4544:       *   { 'user': 'fred',    'active': false },
 4545:       *   { 'user': 'pebbles', 'active': false }
 4546:       * ];
 4547:       *
 4548:       * resolve( _.takeRightWhile(users, function(o) { return !o.active; }) );
 4549:       * // => ['fred', 'pebbles']
 4550:       *
 4551:       * // using the `_.matches` callback shorthand
 4552:       * resolve( _.takeRightWhile(users, { 'user': 'pebbles', 'active': false }) );
 4553:       * // => ['pebbles']
 4554:       *
 4555:       * // using the `_.matchesProperty` callback shorthand
 4556:       * resolve( _.takeRightWhile(users, ['active', false]) );
 4557:       * // => ['fred', 'pebbles']
 4558:       *
 4559:       * // using the `_.property` callback shorthand
 4560:       * resolve( _.takeRightWhile(users, 'active') );
 4561:       * // => []
***** LODASH\RD\ORIGINAL.JS
 4548:       *
 4549:       * _.takeRight([1, 2, 3]);
 4550:       * // => [3]
 4551:       *
 4552:       * _.takeRight([1, 2, 3], 2);
 4553:       * // => [2, 3]
 4554:       *
 4555:       * _.takeRight([1, 2, 3], 5);
 4556:       * // => [1, 2, 3]
 4557:       *
 4558:       * _.takeRight([1, 2, 3], 0);
 4559:       * // => []
*****

***** LODASH\RD\50.js
 4562:       */
 4563:          function takeRightWhile(array, predicate) {
 4564:              return array && array.length ? baseWhile(array, getIteratee(predicate), false, true) : [];
 4565:          }
***** LODASH\RD\ORIGINAL.JS
 4560:       */
 4561:          function takeRight(array, n, guard) {
 4562:              var length = array ? array.length : 0;
 4563:              if (!length) {
 4564:                  return [];
 4565:              }
 4566:              n = guard || n == null ? 1 : toInteger(n);
 4567:              n = length - n;
 4568:              return baseSlice(array, n < 0 ? 0 : n);
 4569:          }
*****

***** LODASH\RD\50.js
 4566:          /**
 4567:       * Creates a slice of `array` with elements taken from the beginning. Elements
 4568:       * are taken until `predicate` returns falsey. The predicate is invoked with
 4569:       * three arguments: (value, index, array).
 4570:       *
***** LODASH\RD\ORIGINAL.JS
 4570:          /**
 4571:       * Creates a slice of `array` with elements taken from the end. Elements are
 4572:       * taken until `predicate` returns falsey. The predicate is invoked with three
 4573:       * arguments: (value, index, array).
 4574:       *
*****

***** LODASH\RD\50.js
 4581:       * var users = [
 4582:       *   { 'user': 'barney',  'active': false },
 4583:       *   { 'user': 'fred',    'active': false},
 4584:       *   { 'user': 'pebbles', 'active': true }
 4585:       * ];
***** LODASH\RD\ORIGINAL.JS
 4585:       * var users = [
 4586:       *   { 'user': 'barney',  'active': true },
 4587:       *   { 'user': 'fred',    'active': false },
 4588:       *   { 'user': 'pebbles', 'active': false }
 4589:       * ];
*****

***** LODASH\RD\50.js
 4586:       *
 4587:       * resolve( _.takeWhile(users, function(o) { return !o.active; }) );
 4588:       * // => ['barney', 'fred']
 4589:       *
***** LODASH\RD\ORIGINAL.JS
 4590:       *
 4591:       * resolve( _.takeRightWhile(users, function(o) { return !o.active; }) );
 4592:       * // => ['fred', 'pebbles']
 4593:       *
*****

***** LODASH\RD\50.js
 4590:       * // using the `_.matches` callback shorthand
 4591:       * resolve( _.takeWhile(users, { 'user': 'barney', 'active': false }) );
 4592:       * // => ['barney']
 4593:       *
***** LODASH\RD\ORIGINAL.JS
 4594:       * // using the `_.matches` callback shorthand
 4595:       * resolve( _.takeRightWhile(users, { 'user': 'pebbles', 'active': false }) );
 4596:       * // => ['pebbles']
 4597:       *
*****

***** LODASH\RD\50.js
 4594:       * // using the `_.matchesProperty` callback shorthand
 4595:       * resolve( _.takeWhile(users, ['active', false]) );
 4596:       * // => ['barney', 'fred']
 4597:       *
***** LODASH\RD\ORIGINAL.JS
 4598:       * // using the `_.matchesProperty` callback shorthand
 4599:       * resolve( _.takeRightWhile(users, ['active', false]) );
 4600:       * // => ['fred', 'pebbles']
 4601:       *
*****

***** LODASH\RD\50.js
 4598:       * // using the `_.property` callback shorthand
 4599:       * resolve( _.takeWhile(users, 'active') );
 4600:       * // => []
***** LODASH\RD\ORIGINAL.JS
 4602:       * // using the `_.property` callback shorthand
 4603:       * resolve( _.takeRightWhile(users, 'active') );
 4604:       * // => []
*****

***** LODASH\RD\50.js
 4601:       */
 4602:          function takeWhile(array, predicate) {
 4603:              return array && array.length ? baseWhile(array, getIteratee(predicate)) : [];
 4604:          }
***** LODASH\RD\ORIGINAL.JS
 4605:       */
 4606:          function takeRightWhile(array, predicate) {
 4607:              return array && array.length ? baseWhile(array, getIteratee(predicate), false, true) : [];
 4608:          }
*****

***** LODASH\RD\50.js
 4605:          /**
 4606:       * Creates an array of unique values, in order, from all of the provided arrays
 4607:       * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4608:       * for equality comparisons.
 4609:       *
***** LODASH\RD\ORIGINAL.JS
 4609:          /**
 4610:       * Creates a slice of `array` with elements taken from the beginning. Elements
 4611:       * are taken until `predicate` returns falsey. The predicate is invoked with
 4612:       * three arguments: (value, index, array).
 4613:       *
*****

***** LODASH\RD\50.js
 4612:       * @category Array
 4613:       * @param {...Array} [arrays] The arrays to inspect.
 4614:       * @returns {Array} Returns the new array of combined values.
 4615:       * @example
***** LODASH\RD\ORIGINAL.JS
 4616:       * @category Array
 4617:       * @param {Array} array The array to query.
 4618:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 4619:       * @returns {Array} Returns the slice of `array`.
 4620:       * @example
*****

***** LODASH\RD\50.js
 4616:       *
 4617:       * _.union([1, 2], [4, 2], [2, 1]);
 4618:       * // => [1, 2, 4]
 4619:       */
 4620:          var union = restParam(function (arrays) {
 4621:              return baseUniq(baseFlatten(arrays, false, true));
 4622:          });
 4623:          /**
 4624:       * Creates a duplicate-free version of an array, using
 4625:       * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4626:       * for equality comparisons, in which only the first occurence of each element
 4627:       * is kept. Providing `true` for `isSorted` performs a faster search algorithm
 4628:       * for sorted arrays.
 4629:       *
***** LODASH\RD\ORIGINAL.JS
 4621:       *
 4622:       * var resolve = _.partial(_.map, _, 'user');
 4623:       *
 4624:       * var users = [
 4625:       *   { 'user': 'barney',  'active': false },
 4626:       *   { 'user': 'fred',    'active': false},
 4627:       *   { 'user': 'pebbles', 'active': true }
 4628:       * ];
 4629:       *
 4630:       * resolve( _.takeWhile(users, function(o) { return !o.active; }) );
 4631:       * // => ['barney', 'fred']
 4632:       *
 4633:       * // using the `_.matches` callback shorthand
 4634:       * resolve( _.takeWhile(users, { 'user': 'barney', 'active': false }) );
 4635:       * // => ['barney']
 4636:       *
 4637:       * // using the `_.matchesProperty` callback shorthand
 4638:       * resolve( _.takeWhile(users, ['active', false]) );
 4639:       * // => ['barney', 'fred']
 4640:       *
 4641:       * // using the `_.property` callback shorthand
 4642:       * resolve( _.takeWhile(users, 'active') );
 4643:       * // => []
 4644:       */
 4645:          function takeWhile(array, predicate) {
 4646:              return array && array.length ? baseWhile(array, getIteratee(predicate)) : [];
 4647:          }
 4648:          /**
 4649:       * Creates an array of unique values, in order, from all of the provided arrays
 4650:       * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4651:       * for equality comparisons.
 4652:       *
*****

***** LODASH\RD\50.js
 4632:       * @category Array
 4633:       * @param {Array} array The array to inspect.
 4634:       * @param {boolean} [isSorted] Specify the array is sorted.
 4635:       * @returns {Array} Returns the new duplicate free array.
 4636:       * @example
***** LODASH\RD\ORIGINAL.JS
 4655:       * @category Array
 4656:       * @param {...Array} [arrays] The arrays to inspect.
 4657:       * @returns {Array} Returns the new array of combined values.
 4658:       * @example
*****

***** LODASH\RD\50.js
 4637:       *
 4638:       * _.uniq([2, 1, 2]);
 4639:       * // => [2, 1]
 4640:       *
 4641:       * // using `isSorted`
 4642:       * _.uniq([1, 1, 2], true);
 4643:       * // => [1, 2]
 4644:       */
 4645:          function uniq(array, isSorted) {
 4646:              if (!(array && array.length)) {
 4647:                  return [];
 4648:              }
 4649:              return isSorted && typeof isSorted == 'boolean' && getIndexOf() === baseIndexOf ? sortedUniq(array) : baseUniq(arra
 4650:  y);
 4651:          }
 4652:          /**
 4653:       * This method is like `_.uniq` except that it accepts `iteratee` which is
 4654:       * invoked for each element in `array` to generate the criterion by which
 4655:       * uniqueness is computed. The iteratee is invoked with one argument: (value).
 4656:       *
***** LODASH\RD\ORIGINAL.JS
 4659:       *
 4660:       * _.union([1, 2], [4, 2], [2, 1]);
 4661:       * // => [1, 2, 4]
 4662:       */
 4663:          var union = restParam(function (arrays) {
 4664:              return baseUniq(baseFlatten(arrays, false, true));
 4665:          });
 4666:          /**
 4667:       * Creates a duplicate-free version of an array, using
 4668:       * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4669:       * for equality comparisons, in which only the first occurence of each element
 4670:       * is kept. Providing `true` for `isSorted` performs a faster search algorithm
 4671:       * for sorted arrays.
 4672:       *
*****

***** LODASH\RD\50.js
 4661:       * @param {boolean} [isSorted] Specify the array is sorted.
 4662:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4663:       * @returns {Array} Returns the new duplicate free array.
***** LODASH\RD\ORIGINAL.JS
 4677:       * @param {boolean} [isSorted] Specify the array is sorted.
 4678:       * @returns {Array} Returns the new duplicate free array.
*****

***** LODASH\RD\50.js
 4665:       *
 4666:       * _.uniqBy([1, 2.5, 1.5, 2], function(n) {
 4667:       *   return Math.floor(n);
 4668:       * });
 4669:       * // => [1, 2.5]
 4670:       *
 4671:       * // using the `_.property` callback shorthand
 4672:       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 4673:       * // => [{ 'x': 1 }, { 'x': 2 }]
 4674:       */
 4675:          function uniqBy(array, isSorted, iteratee) {
 4676:              if (!(array && array.length)) {
***** LODASH\RD\ORIGINAL.JS
 4680:       *
 4681:       * _.uniq([2, 1, 2]);
 4682:       * // => [2, 1]
 4683:       *
 4684:       * // using `isSorted`
 4685:       * _.uniq([1, 1, 2], true);
 4686:       * // => [1, 2]
 4687:       */
 4688:          function uniq(array, isSorted) {
 4689:              if (!(array && array.length)) {
*****

***** LODASH\RD\50.js
 4678:              }
 4679:              if (isSorted != null && typeof isSorted != 'boolean') {
 4680:                  iteratee = isSorted;
 4681:                  isSorted = false;
 4682:              }
 4683:              var toIteratee = getIteratee();
 4684:              if (!(iteratee == null && toIteratee === baseIteratee)) {
 4685:                  iteratee = toIteratee(iteratee);
 4686:              }
 4687:              return isSorted && getIndexOf() === baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
 4688:          }
***** LODASH\RD\ORIGINAL.JS
 4691:              }
 4692:              return isSorted && typeof isSorted == 'boolean' && getIndexOf() === baseIndexOf ? sortedUniq(array) : baseUniq(arra
 4693:  y);
 4694:          }
*****

***** LODASH\RD\50.js
 4689:          /**
 4690:       * This method is like `_.zip` except that it accepts an array of grouped
 4691:       * elements and creates an array regrouping the elements to their pre-zip
 4692:       * configuration.
 4693:       *
***** LODASH\RD\ORIGINAL.JS
 4695:          /**
 4696:       * This method is like `_.uniq` except that it accepts `iteratee` which is
 4697:       * invoked for each element in `array` to generate the criterion by which
 4698:       * uniqueness is computed. The iteratee is invoked with one argument: (value).
 4699:       *
*****

***** LODASH\RD\50.js
 4696:       * @category Array
 4697:       * @param {Array} array The array of grouped elements to process.
 4698:       * @returns {Array} Returns the new array of regrouped elements.
 4699:       * @example
***** LODASH\RD\ORIGINAL.JS
 4702:       * @category Array
 4703:       * @param {Array} array The array to inspect.
 4704:       * @param {boolean} [isSorted] Specify the array is sorted.
 4705:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 4706:       * @returns {Array} Returns the new duplicate free array.
 4707:       * @example
*****

***** LODASH\RD\50.js
 4700:       *
 4701:       * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
 4702:       * // => [['fred', 30, true], ['barney', 40, false]]
 4703:       *
 4704:       * _.unzip(zipped);
 4705:       * // => [['fred', 'barney'], [30, 40], [true, false]]
 4706:       */
 4707:          function unzip(array) {
 4708:              if (!(array && array.length)) {
***** LODASH\RD\ORIGINAL.JS
 4708:       *
 4709:       * _.uniqBy([1, 2.5, 1.5, 2], function(n) {
 4710:       *   return Math.floor(n);
 4711:       * });
 4712:       * // => [1, 2.5]
 4713:       *
 4714:       * // using the `_.property` callback shorthand
 4715:       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 4716:       * // => [{ 'x': 1 }, { 'x': 2 }]
 4717:       */
 4718:          function uniqBy(array, isSorted, iteratee) {
 4719:              if (!(array && array.length)) {
*****

***** LODASH\RD\50.js
 4710:              }
 4711:              var index = -1, length = 0;
 4712:              array = arrayFilter(array, function (group) {
 4713:                  if (isObject(group) && isArrayLike(group)) {
 4714:                      length = nativeMax(group.length, length);
 4715:                      return true;
 4716:                  }
 4717:              });
 4718:              var result = Array(length);
 4719:              while (++index < length) {
 4720:                  result[index] = arrayMap(array, baseProperty(index));
 4721:              }
 4722:              return result;
 4723:          }
***** LODASH\RD\ORIGINAL.JS
 4721:              }
 4722:              if (isSorted != null && typeof isSorted != 'boolean') {
 4723:                  iteratee = isSorted;
 4724:                  isSorted = false;
 4725:              }
 4726:              var toIteratee = getIteratee();
 4727:              if (!(iteratee == null && toIteratee === baseIteratee)) {
 4728:                  iteratee = toIteratee(iteratee);
 4729:              }
 4730:              return isSorted && getIndexOf() === baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
 4731:          }
*****

***** LODASH\RD\50.js
 4724:          /**
 4725:       * This method is like `_.unzip` except that it accepts `iteratee` to specify
 4726:       * how regrouped values should be combined. The iteratee is invoked with four
 4727:       * arguments: (accumulator, value, index, group).
 4728:       *
***** LODASH\RD\ORIGINAL.JS
 4732:          /**
 4733:       * This method is like `_.zip` except that it accepts an array of grouped
 4734:       * elements and creates an array regrouping the elements to their pre-zip
 4735:       * configuration.
 4736:       *
*****

***** LODASH\RD\50.js
 4732:       * @param {Array} array The array of grouped elements to process.
 4733:       * @param {Function} [iteratee=_.identity] The function to combine regrouped values.
 4734:       * @returns {Array} Returns the new array of regrouped elements.
***** LODASH\RD\ORIGINAL.JS
 4740:       * @param {Array} array The array of grouped elements to process.
 4741:       * @returns {Array} Returns the new array of regrouped elements.
*****

***** LODASH\RD\50.js
 4736:       *
 4737:       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 4738:       * // => [[1, 10, 100], [2, 20, 200]]
 4739:       *
 4740:       * _.unzipWith(zipped, _.add);
 4741:       * // => [3, 30, 300]
 4742:       */
 4743:          function unzipWith(array, iteratee) {
 4744:              if (!(array && array.length)) {
***** LODASH\RD\ORIGINAL.JS
 4743:       *
 4744:       * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
 4745:       * // => [['fred', 30, true], ['barney', 40, false]]
 4746:       *
 4747:       * _.unzip(zipped);
 4748:       * // => [['fred', 'barney'], [30, 40], [true, false]]
 4749:       */
 4750:          function unzip(array) {
 4751:              if (!(array && array.length)) {
*****

***** LODASH\RD\50.js
 4746:              }
 4747:              var result = unzip(array);
 4748:              if (iteratee == null) {
 4749:                  return result;
 4750:              }
 4751:              return arrayMap(result, function (group) {
 4752:                  return arrayReduce(group, iteratee, undefined, true);
 4753:              });
 4754:          }
***** LODASH\RD\ORIGINAL.JS
 4753:              }
 4754:              var index = -1, length = 0;
 4755:              array = arrayFilter(array, function (group) {
 4756:                  if (isObject(group) && isArrayLike(group)) {
 4757:                      length = nativeMax(group.length, length);
 4758:                      return true;
 4759:                  }
 4760:              });
 4761:              var result = Array(length);
 4762:              while (++index < length) {
 4763:                  result[index] = arrayMap(array, baseProperty(index));
 4764:              }
 4765:              return result;
 4766:          }
*****

***** LODASH\RD\50.js
 4755:          /**
 4756:       * Creates an array excluding all provided values using
 4757:       * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4758:       * for equality comparisons.
 4759:       *
***** LODASH\RD\ORIGINAL.JS
 4767:          /**
 4768:       * This method is like `_.unzip` except that it accepts `iteratee` to specify
 4769:       * how regrouped values should be combined. The iteratee is invoked with four
 4770:       * arguments: (accumulator, value, index, group).
 4771:       *
*****

***** LODASH\RD\50.js
 4762:       * @category Array
 4763:       * @param {Array} array The array to filter.
 4764:       * @param {...*} [values] The values to exclude.
 4765:       * @returns {Array} Returns the new array of filtered values.
 4766:       * @example
***** LODASH\RD\ORIGINAL.JS
 4774:       * @category Array
 4775:       * @param {Array} array The array of grouped elements to process.
 4776:       * @param {Function} [iteratee=_.identity] The function to combine regrouped values.
 4777:       * @returns {Array} Returns the new array of regrouped elements.
 4778:       * @example
*****

***** LODASH\RD\50.js
 4767:       *
 4768:       * _.without([1, 2, 1, 3], 1, 2);
 4769:       * // => [3]
 4770:       */
 4771:          var without = restParam(function (array, values) {
 4772:              return isObject(array) && isArrayLike(array) ? baseDifference(array, values) : [];
 4773:          });
 4774:          /**
 4775:       * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 4776:       * of the provided arrays.
 4777:       *
***** LODASH\RD\ORIGINAL.JS
 4779:       *
 4780:       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 4781:       * // => [[1, 10, 100], [2, 20, 200]]
 4782:       *
 4783:       * _.unzipWith(zipped, _.add);
 4784:       * // => [3, 30, 300]
 4785:       */
 4786:          function unzipWith(array, iteratee) {
 4787:              if (!(array && array.length)) {
 4788:                  return [];
 4789:              }
 4790:              var result = unzip(array);
 4791:              if (iteratee == null) {
 4792:                  return result;
 4793:              }
 4794:              return arrayMap(result, function (group) {
 4795:                  return arrayReduce(group, iteratee, undefined, true);
 4796:              });
 4797:          }
 4798:          /**
 4799:       * Creates an array excluding all provided values using
 4800:       * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 4801:       * for equality comparisons.
 4802:       *
*****

***** LODASH\RD\50.js
 4780:       * @category Array
 4781:       * @param {...Array} [arrays] The arrays to inspect.
 4782:       * @returns {Array} Returns the new array of values.
 4783:       * @example
***** LODASH\RD\ORIGINAL.JS
 4805:       * @category Array
 4806:       * @param {Array} array The array to filter.
 4807:       * @param {...*} [values] The values to exclude.
 4808:       * @returns {Array} Returns the new array of filtered values.
 4809:       * @example
*****

***** LODASH\RD\50.js
 4784:       *
 4785:       * _.xor([1, 2], [4, 2]);
***** LODASH\RD\ORIGINAL.JS
 4810:       *
 4811:       * _.without([1, 2, 1, 3], 1, 2);
 4812:       * // => [3]
 4813:       */
 4814:          var without = restParam(function (array, values) {
 4815:              return isObject(array) && isArrayLike(array) ? baseDifference(array, values) : [];
 4816:          });
 4817:          /**
 4818:       * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 4819:       * of the provided arrays.
 4820:       *
 4821:       * @static
 4822:       * @memberOf _
 4823:       * @category Array
 4824:       * @param {...Array} [arrays] The arrays to inspect.
 4825:       * @returns {Array} Returns the new array of values.
 4826:       * @example
 4827:       *
 4828:       * _.xor([1, 2], [4, 2]);
*****

***** LODASH\RD\50.js
 5309:              predicate = getIteratee(predicate);
 5310:              if (isArray()) {
 5311:                  var index = baseFindIndex(collection, predicate, true);
***** LODASH\RD\ORIGINAL.JS
 5352:              predicate = getIteratee(predicate);
 5353:              if (isArray(collection)) {
 5354:                  var index = baseFindIndex(collection, predicate, true);
*****

***** LODASH\RD\50.js
 5496:                  var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
 5497:                  result[++index] = func ? func.apply(value, args) : invokePath(value, path);
 5498:              });
***** LODASH\RD\ORIGINAL.JS
 5539:                  var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
 5540:                  result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
 5541:              });
*****

***** LODASH\RD\50.js
 7298:          function isFinite(value) {
 7299:              return typeof value == 'number' && nativeIsFinite(value);
 7300:          }
 7301:          /**
 7302:       * Checks if `value` is classified as a `Function` object.
 7303:       *
***** LODASH\RD\ORIGINAL.JS
 7341:          /**
 7342:       * Checks if `value` is a finite primitive number.
 7343:       *
 7344:       * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
 7345:       *
*****

***** LODASH\RD\50.js
 7307:       * @param {*} value The value to check.
 7308:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7309:       * @example
***** LODASH\RD\ORIGINAL.JS
 7349:       * @param {*} value The value to check.
 7350:       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
 7351:       * @example
*****

***** LODASH\RD\50.js
 7310:       *
 7311:       * _.isFunction(_);
 7312:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7352:       *
 7353:       * _.isFinite(10);
 7354:       * // => true
*****

***** LODASH\RD\50.js
 7313:       *
 7314:       * _.isFunction(/abc/);
 7315:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7355:       *
 7356:       * _.isFinite('10');
 7357:       * // => false
 7358:       *
 7359:       * _.isFinite(true);
 7360:       * // => false
 7361:       *
 7362:       * _.isFinite(Object(10));
 7363:       * // => false
 7364:       *
 7365:       * _.isFinite(Infinity);
 7366:       * // => false
*****

***** LODASH\RD\50.js
 7316:       */
 7317:          function isFunction(value) {
 7318:              // The use of `Object#toString` avoids issues with the `typeof` operator
 7319:              // in Safari 8 which returns 'object' for typed array constructors, and
 7320:              // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
 7321:              return isObject(value) && objToString.call(value) == funcTag;
 7322:          }
***** LODASH\RD\ORIGINAL.JS
 7367:       */
 7368:          function isFinite(value) {
 7369:              return typeof value == 'number' && nativeIsFinite(value);
 7370:          }
*****

***** LODASH\RD\50.js
 7323:          /**
 7324:       * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 7325:       * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 7326:       *
***** LODASH\RD\ORIGINAL.JS
 7371:          /**
 7372:       * Checks if `value` is classified as a `Function` object.
 7373:       *
*****

***** LODASH\RD\50.js
 7330:       * @param {*} value The value to check.
 7331:       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 7332:       * @example
***** LODASH\RD\ORIGINAL.JS
 7377:       * @param {*} value The value to check.
 7378:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7379:       * @example
*****

***** LODASH\RD\50.js
 7333:       *
 7334:       * _.isObject({});
 7335:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7380:       *
 7381:       * _.isFunction(_);
 7382:       * // => true
*****

***** LODASH\RD\50.js
 7336:       *
 7337:       * _.isObject([1, 2, 3]);
 7338:       * // => true
 7339:       *
 7340:       * _.isObject(1);
 7341:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7383:       *
 7384:       * _.isFunction(/abc/);
 7385:       * // => false
*****

***** LODASH\RD\50.js
 7342:       */
 7343:          function isObject(value) {
 7344:              // Avoid a V8 JIT bug in Chrome 19-20.
 7345:              // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
 7346:              var type = typeof value;
 7347:              return !!value && (type == 'object' || type == 'function');
 7348:          }
***** LODASH\RD\ORIGINAL.JS
 7386:       */
 7387:          function isFunction(value) {
 7388:              // The use of `Object#toString` avoids issues with the `typeof` operator
 7389:              // in Safari 8 which returns 'object' for typed array constructors, and
 7390:              // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
 7391:              return isObject(value) && objToString.call(value) == funcTag;
 7392:          }
*****

***** LODASH\RD\50.js
 7349:          /**
 7350:       * Performs a deep comparison between `object` and `source` to determine if
 7351:       * `object` contains equivalent property values.
 7352:       *
 7353:       * **Note:** This method supports comparing properties of arrays, booleans,
 7354:       * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
 7355:       * and DOM nodes are **not** supported. Provide a customizer function to extend
 7356:       * support for comparing other values.
 7357:       *
***** LODASH\RD\ORIGINAL.JS
 7393:          /**
 7394:       * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 7395:       * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 7396:       *
*****

***** LODASH\RD\50.js
 7360:       * @category Lang
 7361:       * @param {Object} object The object to inspect.
 7362:       * @param {Object} source The object of property values to match.
 7363:       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 7364:       * @example
***** LODASH\RD\ORIGINAL.JS
 7399:       * @category Lang
 7400:       * @param {*} value The value to check.
 7401:       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 7402:       * @example
*****

***** LODASH\RD\50.js
 7365:       *
 7366:       * var object = { 'user': 'fred', 'age': 40 };
 7367:       *
 7368:       * _.isMatch(object, { 'age': 40 });
 7369:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7403:       *
 7404:       * _.isObject({});
 7405:       * // => true
*****

***** LODASH\RD\50.js
 7370:       *
 7371:       * _.isMatch(object, { 'age': 36 });
 7372:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7406:       *
 7407:       * _.isObject([1, 2, 3]);
 7408:       * // => true
 7409:       *
 7410:       * _.isObject(1);
 7411:       * // => false
*****

***** LODASH\RD\50.js
 7373:       */
 7374:          function isMatch(object, source) {
 7375:              return baseIsMatch(object, source, getMatchData(source));
 7376:          }
***** LODASH\RD\ORIGINAL.JS
 7412:       */
 7413:          function isObject(value) {
 7414:              // Avoid a V8 JIT bug in Chrome 19-20.
 7415:              // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
 7416:              var type = typeof value;
 7417:              return !!value && (type == 'object' || type == 'function');
 7418:          }
*****

***** LODASH\RD\50.js
 7377:          /**
 7378:       * This method is like `_.isMatch` except that it accepts `customizer` which
 7379:       * is invoked to compare values. If `customizer` returns `undefined` comparisons
 7380:       * are handled by the method instead. The `customizer` is invoked with three
 7381:       * arguments: (objValue, srcValue, index|key, object, source).
 7382:       *
***** LODASH\RD\ORIGINAL.JS
 7419:          /**
 7420:       * Performs a deep comparison between `object` and `source` to determine if
 7421:       * `object` contains equivalent property values.
 7422:       *
 7423:       * **Note:** This method supports comparing properties of arrays, booleans,
 7424:       * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
 7425:       * and DOM nodes are **not** supported. Provide a customizer function to extend
 7426:       * support for comparing other values.
 7427:       *
*****

***** LODASH\RD\50.js
 7387:       * @param {Object} source The object of property values to match.
 7388:       * @param {Function} [customizer] The function to customize comparisons.
 7389:       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
***** LODASH\RD\ORIGINAL.JS
 7432:       * @param {Object} source The object of property values to match.
 7433:       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
*****

***** LODASH\RD\50.js
 7391:       *
 7392:       * var object = { 'greeting': 'hello' };
 7393:       * var source = { 'greeting': 'hi' };
 7394:       *
 7395:       * _.isMatchWith(object, source, function(value, other) {
 7396:       *   var reHello = /^h(?:i|ello)$/;
 7397:       *   if (reHello.test(value) && reHello.test(other)) {
 7398:       *     return true;
 7399:       *   }
 7400:       * });
 7401:       * // => true
 7402:       */
 7403:          function isMatchWith(object, source, customizer) {
 7404:              customizer = typeof customizer == 'function' ? customizer : undefined;
 7405:              return baseIsMatch(object, source, getMatchData(source), customizer);
 7406:          }
***** LODASH\RD\ORIGINAL.JS
 7435:       *
 7436:       * var object = { 'user': 'fred', 'age': 40 };
 7437:       *
 7438:       * _.isMatch(object, { 'age': 40 });
 7439:       * // => true
 7440:       *
 7441:       * _.isMatch(object, { 'age': 36 });
 7442:       * // => false
 7443:       */
 7444:          function isMatch(object, source) {
 7445:              return baseIsMatch(object, source, getMatchData(source));
 7446:          }
*****

***** LODASH\RD\50.js
 7407:          /**
 7408:       * Checks if `value` is `NaN`.
 7409:       *
 7410:       * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
 7411:       * which returns `true` for `undefined` and other non-numeric values.
 7412:       *
***** LODASH\RD\ORIGINAL.JS
 7447:          /**
 7448:       * This method is like `_.isMatch` except that it accepts `customizer` which
 7449:       * is invoked to compare values. If `customizer` returns `undefined` comparisons
 7450:       * are handled by the method instead. The `customizer` is invoked with three
 7451:       * arguments: (objValue, srcValue, index|key, object, source).
 7452:       *
*****

***** LODASH\RD\50.js
 7415:       * @category Lang
 7416:       * @param {*} value The value to check.
 7417:       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 7418:       * @example
***** LODASH\RD\ORIGINAL.JS
 7455:       * @category Lang
 7456:       * @param {Object} object The object to inspect.
 7457:       * @param {Object} source The object of property values to match.
 7458:       * @param {Function} [customizer] The function to customize comparisons.
 7459:       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 7460:       * @example
*****

***** LODASH\RD\50.js
 7419:       *
 7420:       * _.isNaN(NaN);
 7421:       * // => true
 7422:       *
 7423:       * _.isNaN(new Number(NaN));
 7424:       * // => true
 7425:       *
 7426:       * isNaN(undefined);
 7427:       * // => true
 7428:       *
 7429:       * _.isNaN(undefined);
 7430:       * // => false
 7431:       */
 7432:          function isNaN(value) {
 7433:              // An `NaN` primitive is the only value that is not equal to itself.
 7434:              // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.
 7435:              return isNumber(value) && value != +value;
 7436:          }
***** LODASH\RD\ORIGINAL.JS
 7461:       *
 7462:       * var object = { 'greeting': 'hello' };
 7463:       * var source = { 'greeting': 'hi' };
 7464:       *
 7465:       * _.isMatchWith(object, source, function(value, other) {
 7466:       *   var reHello = /^h(?:i|ello)$/;
 7467:       *   if (reHello.test(value) && reHello.test(other)) {
 7468:       *     return true;
 7469:       *   }
 7470:       * });
 7471:       * // => true
 7472:       */
 7473:          function isMatchWith(object, source, customizer) {
 7474:              customizer = typeof customizer == 'function' ? customizer : undefined;
 7475:              return baseIsMatch(object, source, getMatchData(source), customizer);
 7476:          }
*****

***** LODASH\RD\50.js
 7437:          /**
 7438:       * Checks if `value` is a native function.
 7439:       *
***** LODASH\RD\ORIGINAL.JS
 7477:          /**
 7478:       * Checks if `value` is `NaN`.
 7479:       *
 7480:       * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
 7481:       * which returns `true` for `undefined` and other non-numeric values.
 7482:       *
*****

***** LODASH\RD\50.js
 7443:       * @param {*} value The value to check.
 7444:       * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 7445:       * @example
***** LODASH\RD\ORIGINAL.JS
 7486:       * @param {*} value The value to check.
 7487:       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 7488:       * @example
*****

***** LODASH\RD\50.js
 7446:       *
 7447:       * _.isNative(Array.prototype.push);
 7448:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7489:       *
 7490:       * _.isNaN(NaN);
 7491:       * // => true
*****

***** LODASH\RD\50.js
 7449:       *
 7450:       * _.isNative(_);
 7451:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7492:       *
 7493:       * _.isNaN(new Number(NaN));
 7494:       * // => true
 7495:       *
 7496:       * isNaN(undefined);
 7497:       * // => true
 7498:       *
 7499:       * _.isNaN(undefined);
 7500:       * // => false
*****

***** LODASH\RD\50.js
 7452:       */
 7453:          function isNative(value) {
 7454:              if (value == null) {
 7455:                  return false;
 7456:              }
 7457:              if (isFunction(value)) {
 7458:                  return reIsNative.test(fnToString.call(value));
 7459:              }
 7460:              return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
 7461:          }
***** LODASH\RD\ORIGINAL.JS
 7501:       */
 7502:          function isNaN(value) {
 7503:              // An `NaN` primitive is the only value that is not equal to itself.
 7504:              // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.
 7505:              return isNumber(value) && value != +value;
 7506:          }
*****

***** LODASH\RD\50.js
 7462:          /**
 7463:       * Checks if `value` is `null`.
 7464:       *
***** LODASH\RD\ORIGINAL.JS
 7507:          /**
 7508:       * Checks if `value` is a native function.
 7509:       *
*****

***** LODASH\RD\50.js
 7468:       * @param {*} value The value to check.
 7469:       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 7470:       * @example
***** LODASH\RD\ORIGINAL.JS
 7513:       * @param {*} value The value to check.
 7514:       * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 7515:       * @example
*****

***** LODASH\RD\50.js
 7471:       *
 7472:       * _.isNull(null);
 7473:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7516:       *
 7517:       * _.isNative(Array.prototype.push);
 7518:       * // => true
*****

***** LODASH\RD\50.js
 7474:       *
 7475:       * _.isNull(void 0);
 7476:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7519:       *
 7520:       * _.isNative(_);
 7521:       * // => false
*****

***** LODASH\RD\50.js
 7477:       */
 7478:          function isNull(value) {
 7479:              return value === null;
 7480:          }
***** LODASH\RD\ORIGINAL.JS
 7522:       */
 7523:          function isNative(value) {
 7524:              if (value == null) {
 7525:                  return false;
 7526:              }
 7527:              if (isFunction(value)) {
 7528:                  return reIsNative.test(fnToString.call(value));
 7529:              }
 7530:              return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
 7531:          }
*****

***** LODASH\RD\50.js
 7481:          /**
 7482:       * Checks if `value` is `null` or `undefined`.
 7483:       *
***** LODASH\RD\ORIGINAL.JS
 7532:          /**
 7533:       * Checks if `value` is `null`.
 7534:       *
*****

***** LODASH\RD\50.js
 7487:       * @param {*} value The value to check.
 7488:       * @returns {boolean} Returns `true` if `value` is `null` or `undefined`, else `false`.
 7489:       * @example
***** LODASH\RD\ORIGINAL.JS
 7538:       * @param {*} value The value to check.
 7539:       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 7540:       * @example
*****

***** LODASH\RD\50.js
 7490:       *
 7491:       * _.isNil(null);
 7492:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7541:       *
 7542:       * _.isNull(null);
 7543:       * // => true
*****

***** LODASH\RD\50.js
 7493:       *
 7494:       * _.isNil();
 7495:       * // => true
 7496:       *
 7497:       * _.isNil(undefined);
 7498:       * // => true
 7499:       *
 7500:       * _.isNil(NaN);
 7501:       * // => false
 7502:       *
 7503:       * _.isNil(void 0);
 7504:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7544:       *
 7545:       * _.isNull(void 0);
 7546:       * // => false
*****

***** LODASH\RD\50.js
 7505:       */
 7506:          function isNil(value) {
 7507:              return value == null;
 7508:          }
***** LODASH\RD\ORIGINAL.JS
 7547:       */
 7548:          function isNull(value) {
 7549:              return value === null;
 7550:          }
*****

***** LODASH\RD\50.js
 7509:          /**
 7510:       * Checks if `value` is classified as a `Number` primitive or object.
 7511:       *
 7512:       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 7513:       * as numbers, use the `_.isFinite` method.
 7514:       *
***** LODASH\RD\ORIGINAL.JS
 7551:          /**
 7552:       * Checks if `value` is `null` or `undefined`.
 7553:       *
*****

***** LODASH\RD\50.js
 7518:       * @param {*} value The value to check.
 7519:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7520:       * @example
***** LODASH\RD\ORIGINAL.JS
 7557:       * @param {*} value The value to check.
 7558:       * @returns {boolean} Returns `true` if `value` is `null` or `undefined`, else `false`.
 7559:       * @example
*****

***** LODASH\RD\50.js
 7521:       *
 7522:       * _.isNumber(8.4);
 7523:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7560:       *
 7561:       * _.isNil(null);
 7562:       * // => true
*****

***** LODASH\RD\50.js
 7524:       *
 7525:       * _.isNumber(NaN);
 7526:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7563:       *
 7564:       * _.isNil();
 7565:       * // => true
*****

***** LODASH\RD\50.js
 7527:       *
 7528:       * _.isNumber('8.4');
 7529:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7566:       *
 7567:       * _.isNil(undefined);
 7568:       * // => true
 7569:       *
 7570:       * _.isNil(NaN);
 7571:       * // => false
 7572:       *
 7573:       * _.isNil(void 0);
 7574:       * // => false
*****

***** LODASH\RD\50.js
 7530:       */
 7531:          function isNumber(value) {
 7532:              return typeof value == 'number' || isObjectLike(value) && objToString.call(value) == numberTag;
 7533:          }
***** LODASH\RD\ORIGINAL.JS
 7575:       */
 7576:          function isNil(value) {
 7577:              return value == null;
 7578:          }
*****

***** LODASH\RD\50.js
 7534:          /**
 7535:       * Checks if `value` is a plain object, that is, an object created by the
 7536:       * `Object` constructor or one with a `[[Prototype]]` of `null`.
 7537:       *
***** LODASH\RD\ORIGINAL.JS
 7579:          /**
 7580:       * Checks if `value` is classified as a `Number` primitive or object.
 7581:       *
 7582:       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 7583:       * as numbers, use the `_.isFinite` method.
 7584:       *
*****

***** LODASH\RD\50.js
 7541:       * @param {*} value The value to check.
 7542:       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 7543:       * @example
***** LODASH\RD\ORIGINAL.JS
 7588:       * @param {*} value The value to check.
 7589:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7590:       * @example
*****

***** LODASH\RD\50.js
 7544:       *
 7545:       * function Foo() {
 7546:       *   this.a = 1;
 7547:       * }
 7548:       *
 7549:       * _.isPlainObject(new Foo);
 7550:       * // => false
 7551:       *
 7552:       * _.isPlainObject([1, 2, 3]);
 7553:       * // => false
 7554:       *
 7555:       * _.isPlainObject({ 'x': 0, 'y': 0 });
 7556:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7591:       *
 7592:       * _.isNumber(8.4);
 7593:       * // => true
*****

***** LODASH\RD\50.js
 7557:       *
 7558:       * _.isPlainObject(Object.create(null));
 7559:       * // => true
 7560:       */
 7561:          function isPlainObject(value) {
 7562:              if (!isObjectLike(value) || objToString.call(value) != objectTag || isHostObject(value)) {
 7563:                  return false;
 7564:              }
 7565:              var proto = typeof value.constructor == 'function' ? getPrototypeOf(value) : objectProto;
 7566:              if (proto === null) {
 7567:                  return true;
 7568:              }
 7569:              var Ctor = proto.constructor;
 7570:              return typeof Ctor == 'function' && Ctor instanceof Ctor && fnToString.call(Ctor) == objCtorString;
 7571:          }
***** LODASH\RD\ORIGINAL.JS
 7594:       *
 7595:       * _.isNumber(NaN);
 7596:       * // => true
 7597:       *
 7598:       * _.isNumber('8.4');
 7599:       * // => false
 7600:       */
 7601:          function isNumber(value) {
 7602:              return typeof value == 'number' || isObjectLike(value) && objToString.call(value) == numberTag;
 7603:          }
*****

***** LODASH\RD\50.js
 7572:          /**
 7573:       * Checks if `value` is classified as a `RegExp` object.
 7574:       *
***** LODASH\RD\ORIGINAL.JS
 7604:          /**
 7605:       * Checks if `value` is a plain object, that is, an object created by the
 7606:       * `Object` constructor or one with a `[[Prototype]]` of `null`.
 7607:       *
*****

***** LODASH\RD\50.js
 7578:       * @param {*} value The value to check.
 7579:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7580:       * @example
***** LODASH\RD\ORIGINAL.JS
 7611:       * @param {*} value The value to check.
 7612:       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 7613:       * @example
*****

***** LODASH\RD\50.js
 7581:       *
 7582:       * _.isRegExp(/abc/);
 7583:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7614:       *
 7615:       * function Foo() {
 7616:       *   this.a = 1;
 7617:       * }
 7618:       *
 7619:       * _.isPlainObject(new Foo);
 7620:       * // => false
 7621:       *
 7622:       * _.isPlainObject([1, 2, 3]);
 7623:       * // => false
 7624:       *
 7625:       * _.isPlainObject({ 'x': 0, 'y': 0 });
 7626:       * // => true
*****

***** LODASH\RD\50.js
 7584:       *
 7585:       * _.isRegExp('/abc/');
 7586:       * // => false
 7587:       */
 7588:          function isRegExp(value) {
 7589:              return isObject(value) && objToString.call(value) == regexpTag;
 7590:          }
***** LODASH\RD\ORIGINAL.JS
 7627:       *
 7628:       * _.isPlainObject(Object.create(null));
 7629:       * // => true
 7630:       */
 7631:          function isPlainObject(value) {
 7632:              if (!isObjectLike(value) || objToString.call(value) != objectTag || isHostObject(value)) {
 7633:                  return false;
 7634:              }
 7635:              var proto = typeof value.constructor == 'function' ? getPrototypeOf(value) : objectProto;
 7636:              if (proto === null) {
 7637:                  return true;
 7638:              }
 7639:              var Ctor = proto.constructor;
 7640:              return typeof Ctor == 'function' && Ctor instanceof Ctor && fnToString.call(Ctor) == objCtorString;
 7641:          }
*****

***** LODASH\RD\50.js
 7591:          /**
 7592:       * Checks if `value` is classified as a `String` primitive or object.
 7593:       *
***** LODASH\RD\ORIGINAL.JS
 7642:          /**
 7643:       * Checks if `value` is classified as a `RegExp` object.
 7644:       *
*****

***** LODASH\RD\50.js
 7600:       *
 7601:       * _.isString('abc');
 7602:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7651:       *
 7652:       * _.isRegExp(/abc/);
 7653:       * // => true
*****

***** LODASH\RD\50.js
 7603:       *
 7604:       * _.isString(1);
 7605:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7654:       *
 7655:       * _.isRegExp('/abc/');
 7656:       * // => false
*****

***** LODASH\RD\50.js
 7606:       */
 7607:          function isString(value) {
 7608:              return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
 7609:          }
***** LODASH\RD\ORIGINAL.JS
 7657:       */
 7658:          function isRegExp(value) {
 7659:              return isObject(value) && objToString.call(value) == regexpTag;
 7660:          }
*****

***** LODASH\RD\50.js
 7610:          /**
 7611:       * Checks if `value` is classified as a typed array.
 7612:       *
***** LODASH\RD\ORIGINAL.JS
 7661:          /**
 7662:       * Checks if `value` is classified as a `String` primitive or object.
 7663:       *
*****

***** LODASH\RD\50.js
 7619:       *
 7620:       * _.isTypedArray(new Uint8Array);
 7621:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7670:       *
 7671:       * _.isString('abc');
 7672:       * // => true
*****

***** LODASH\RD\50.js
 7622:       *
 7623:       * _.isTypedArray([]);
 7624:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7673:       *
 7674:       * _.isString(1);
 7675:       * // => false
*****

***** LODASH\RD\50.js
 7625:       */
 7626:          function isTypedArray(value) {
 7627:              return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
 7628:          }
***** LODASH\RD\ORIGINAL.JS
 7676:       */
 7677:          function isString(value) {
 7678:              return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
 7679:          }
*****

***** LODASH\RD\50.js
 7629:          /**
 7630:       * Checks if `value` is `undefined`.
 7631:       *
***** LODASH\RD\ORIGINAL.JS
 7680:          /**
 7681:       * Checks if `value` is classified as a typed array.
 7682:       *
*****

***** LODASH\RD\50.js
 7635:       * @param {*} value The value to check.
 7636:       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 7637:       * @example
***** LODASH\RD\ORIGINAL.JS
 7686:       * @param {*} value The value to check.
 7687:       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 7688:       * @example
*****

***** LODASH\RD\50.js
 7638:       *
 7639:       * _.isUndefined(void 0);
 7640:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7689:       *
 7690:       * _.isTypedArray(new Uint8Array);
 7691:       * // => true
*****

***** LODASH\RD\50.js
 7641:       *
 7642:       * _.isUndefined(null);
 7643:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7692:       *
 7693:       * _.isTypedArray([]);
 7694:       * // => false
*****

***** LODASH\RD\50.js
 7644:       */
 7645:          function isUndefined(value) {
 7646:              return value === undefined;
 7647:          }
***** LODASH\RD\ORIGINAL.JS
 7695:       */
 7696:          function isTypedArray(value) {
 7697:              return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
 7698:          }
*****

***** LODASH\RD\50.js
 7648:          /**
 7649:       * Checks if `value` is less than `other`.
 7650:       *
***** LODASH\RD\ORIGINAL.JS
 7699:          /**
 7700:       * Checks if `value` is `undefined`.
 7701:       *
*****

***** LODASH\RD\50.js
 7653:       * @category Lang
 7654:       * @param {*} value The value to compare.
 7655:       * @param {*} other The other value to compare.
 7656:       * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
 7657:       * @example
***** LODASH\RD\ORIGINAL.JS
 7704:       * @category Lang
 7705:       * @param {*} value The value to check.
 7706:       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 7707:       * @example
*****

***** LODASH\RD\50.js
 7658:       *
 7659:       * _.lt(1, 3);
 7660:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7708:       *
 7709:       * _.isUndefined(void 0);
 7710:       * // => true
*****

***** LODASH\RD\50.js
 7661:       *
 7662:       * _.lt(3, 3);
 7663:       * // => false
 7664:       *
 7665:       * _.lt(3, 1);
 7666:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7711:       *
 7712:       * _.isUndefined(null);
 7713:       * // => false
*****

***** LODASH\RD\50.js
 7667:       */
 7668:          function lt(value, other) {
 7669:              return value < other;
 7670:          }
***** LODASH\RD\ORIGINAL.JS
 7714:       */
 7715:          function isUndefined(value) {
 7716:              return value === undefined;
 7717:          }
*****

***** LODASH\RD\50.js
 7671:          /**
 7672:       * Checks if `value` is less than or equal to `other`.
 7673:       *
***** LODASH\RD\ORIGINAL.JS
 7718:          /**
 7719:       * Checks if `value` is less than `other`.
 7720:       *
*****

***** LODASH\RD\50.js
 7678:       * @param {*} other The other value to compare.
 7679:       * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
 7680:       * @example
***** LODASH\RD\ORIGINAL.JS
 7725:       * @param {*} other The other value to compare.
 7726:       * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
 7727:       * @example
*****

***** LODASH\RD\50.js
 7681:       *
 7682:       * _.lte(1, 3);
 7683:       * // => true
***** LODASH\RD\ORIGINAL.JS
 7728:       *
 7729:       * _.lt(1, 3);
 7730:       * // => true
*****

***** LODASH\RD\50.js
 7684:       *
 7685:       * _.lte(3, 3);
 7686:       * // => true
 7687:       *
 7688:       * _.lte(3, 1);
 7689:       * // => false
***** LODASH\RD\ORIGINAL.JS
 7731:       *
 7732:       * _.lt(3, 3);
 7733:       * // => false
 7734:       *
 7735:       * _.lt(3, 1);
 7736:       * // => false
*****

***** LODASH\RD\50.js
 7690:       */
 7691:          function lte(value, other) {
 7692:              return value <= other;
 7693:          }
***** LODASH\RD\ORIGINAL.JS
 7737:       */
 7738:          function lt(value, other) {
 7739:              return value < other;
 7740:          }
*****

***** LODASH\RD\50.js
 7694:          /**
 7695:       * Converts `value` to an array.
 7696:       *
***** LODASH\RD\ORIGINAL.JS
 7741:          /**
 7742:       * Checks if `value` is less than or equal to `other`.
 7743:       *
*****

***** LODASH\RD\50.js
 7699:       * @category Lang
 7700:       * @param {*} value The value to convert.
 7701:       * @returns {Array} Returns the converted array.
 7702:       * @example
***** LODASH\RD\ORIGINAL.JS
 7746:       * @category Lang
 7747:       * @param {*} value The value to compare.
 7748:       * @param {*} other The other value to compare.
 7749:       * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
 7750:       * @example
*****

***** LODASH\RD\50.js
 7703:       *
 7704:       * (function() {
 7705:       *   return _.toArray(arguments).slice(1);
 7706:       * }(1, 2, 3));
 7707:       * // => [2, 3]
 7708:       */
 7709:          function toArray(value) {
 7710:              if (!isArrayLike(value)) {
 7711:                  return values(value);
 7712:              }
 7713:              return value.length ? copyArray(value) : [];
 7714:          }
***** LODASH\RD\ORIGINAL.JS
 7751:       *
 7752:       * _.lte(1, 3);
 7753:       * // => true
 7754:       *
 7755:       * _.lte(3, 3);
 7756:       * // => true
 7757:       *
 7758:       * _.lte(3, 1);
 7759:       * // => false
 7760:       */
 7761:          function lte(value, other) {
 7762:              return value <= other;
 7763:          }
*****

***** LODASH\RD\50.js
 7715:          /**
 7716:       * Converts `value` to a plain object flattening inherited enumerable
 7717:       * properties of `value` to own properties of the plain object.
 7718:       *
***** LODASH\RD\ORIGINAL.JS
 7764:          /**
 7765:       * Converts `value` to an array.
 7766:       *
*****

***** LODASH\RD\50.js
 7722:       * @param {*} value The value to convert.
 7723:       * @returns {Object} Returns the converted plain object.
 7724:       * @example
***** LODASH\RD\ORIGINAL.JS
 7770:       * @param {*} value The value to convert.
 7771:       * @returns {Array} Returns the converted array.
 7772:       * @example
*****

***** LODASH\RD\50.js
 7725:       *
 7726:       * function Foo() {
***** LODASH\RD\ORIGINAL.JS
 7773:       *
 7774:       * (function() {
 7775:       *   return _.toArray(arguments).slice(1);
 7776:       * }(1, 2, 3));
 7777:       * // => [2, 3]
 7778:       */
 7779:          function toArray(value) {
 7780:              if (!isArrayLike(value)) {
 7781:                  return values(value);
 7782:              }
 7783:              return value.length ? copyArray(value) : [];
 7784:          }
 7785:          /**
 7786:       * Converts `value` to a plain object flattening inherited enumerable
 7787:       * properties of `value` to own properties of the plain object.
 7788:       *
 7789:       * @static
 7790:       * @memberOf _
 7791:       * @category Lang
 7792:       * @param {*} value The value to convert.
 7793:       * @returns {Object} Returns the converted plain object.
 7794:       * @example
 7795:       *
 7796:       * function Foo() {
*****

***** LODASH\RD\50.js
 8422:          });
 8423:          var mergeWith = createAssigner(function (object, source, customizer) {
 8424:              baseMerge(object, source, customizer);
 8425:          });
 8426:          /**
 8427:       * The opposite of `_.pick`; this method creates an object composed of the
 8428:       * own and inherited enumerable properties of `object` that are not omitted.
 8429:       *
***** LODASH\RD\ORIGINAL.JS
 8492:          });
 8493:          /**
 8494:       * This method is like `_.merge` except that it accepts `customizer` which
 8495:       * is invoked to produce the merged values of the destination and source
 8496:       * properties. If `customizer` returns `undefined` merging is handled by the
 8497:       * method instead. The `customizer` is invoked with seven arguments:
 8498:       * (objValue, srcValue, key, object, source, stackA, stackB).
 8499:       *
*****

***** LODASH\RD\50.js
 8432:       * @category Object
 8433:       * @param {Object} object The source object.
 8434:       * @param {string|string[]} [props] The property names to omit, specified
 8435:       *  individually or in arrays..
 8436:       * @returns {Object} Returns the new object.
 8437:       * @example
***** LODASH\RD\ORIGINAL.JS
 8502:       * @category Object
 8503:       * @param {Object} object The destination object.
 8504:       * @param {...Object} sources The source objects.
 8505:       * @param {Function} customizer The function to customize assigned values.
 8506:       * @returns {Object} Returns `object`.
 8507:       * @example
*****

***** LODASH\RD\50.js
 8438:       *
 8439:       * var object = { 'user': 'fred', 'age': 40 };
 8440:       *
 8441:       * _.omit(object, 'age');
 8442:       * // => { 'user': 'fred' }
 8443:       */
 8444:          var omit = restParam(function (object, props) {
 8445:              if (object == null) {
 8446:                  return {};
 8447:              }
 8448:              props = arrayMap(baseFlatten(props), String);
 8449:              return basePick(object, baseDifference(keysIn(object), props));
 8450:          });
***** LODASH\RD\ORIGINAL.JS
 8508:       *
 8509:       * var object = {
 8510:       *   'fruits': ['apple'],
 8511:       *   'vegetables': ['beet']
 8512:       * };
 8513:       *
 8514:       * var other = {
 8515:       *   'fruits': ['banana'],
 8516:       *   'vegetables': ['carrot']
 8517:       * };
 8518:       *
 8519:       * _.mergeWith(object, other, function(a, b) {
 8520:       *   if (_.isArray(a)) {
 8521:       *     return a.concat(b);
 8522:       *   }
 8523:       * });
 8524:       * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 8525:       */
 8526:          var mergeWith = createAssigner(function (object, source, customizer) {
 8527:              baseMerge(object, source, customizer);
 8528:          });
*****

***** LODASH\RD\50.js
 8451:          /**
 8452:       * The opposite of `_.pickBy`; this method creates an object composed of the
 8453:       * own and inherited enumerable properties of `object` that `predicate`
 8454:       * doesn't return truthy for.
 8455:       *
***** LODASH\RD\ORIGINAL.JS
 8529:          /**
 8530:       * The opposite of `_.pick`; this method creates an object composed of the
 8531:       * own and inherited enumerable properties of `object` that are not omitted.
 8532:       *
*****

***** LODASH\RD\50.js
 8459:       * @param {Object} object The source object.
 8460:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8461:       * @returns {Object} Returns the new object.
***** LODASH\RD\ORIGINAL.JS
 8536:       * @param {Object} object The source object.
 8537:       * @param {string|string[]} [props] The property names to omit, specified
 8538:       *  individually or in arrays..
 8539:       * @returns {Object} Returns the new object.
*****

***** LODASH\RD\50.js
 8465:       *
 8466:       * _.omitBy(object, _.isNumber);
 8467:       * // => { 'user': 'fred' }
***** LODASH\RD\ORIGINAL.JS
 8543:       *
 8544:       * _.omit(object, 'age');
 8545:       * // => { 'user': 'fred' }
*****

***** LODASH\RD\50.js
 8468:       */
 8469:          function omitBy(object, predicate) {
 8470:              predicate = getIteratee(predicate);
 8471:              return basePickBy(object, function (value, key, object) {
 8472:                  return !predicate(value, key, object);
 8473:              });
 8474:          }
 8475:          /**
 8476:       * Creates a two dimensional array of the key-value pairs for `object`,
 8477:       * e.g. `[[key1, value1], [key2, value2]]`.
 8478:       *
***** LODASH\RD\ORIGINAL.JS
 8546:       */
 8547:          var omit = restParam(function (object, props) {
 8548:              if (object == null) {
 8549:                  return {};
 8550:              }
 8551:              props = arrayMap(baseFlatten(props), String);
 8552:              return basePick(object, baseDifference(keysIn(object), props));
 8553:          });
 8554:          /**
 8555:       * The opposite of `_.pickBy`; this method creates an object composed of the
 8556:       * own and inherited enumerable properties of `object` that `predicate`
 8557:       * doesn't return truthy for.
 8558:       *
*****

***** LODASH\RD\50.js
 8481:       * @category Object
 8482:       * @param {Object} object The object to query.
 8483:       * @returns {Array} Returns the new array of key-value pairs.
 8484:       * @example
***** LODASH\RD\ORIGINAL.JS
 8561:       * @category Object
 8562:       * @param {Object} object The source object.
 8563:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8564:       * @returns {Object} Returns the new object.
 8565:       * @example
*****

***** LODASH\RD\50.js
 8485:       *
 8486:       * _.pairs({ 'barney': 36, 'fred': 40 });
 8487:       * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 8488:       */
 8489:          function pairs(object) {
 8490:              object = Object(object);
 8491:              var index = -1, props = keys(object), length = props.length, result = Array(length);
 8492:              while (++index < length) {
 8493:                  var key = props[index];
 8494:                  result[index] = [
 8495:                      key,
 8496:                      object[key]
 8497:                  ];
 8498:              }
 8499:              return result;
 8500:          }
***** LODASH\RD\ORIGINAL.JS
 8566:       *
 8567:       * var object = { 'user': 'fred', 'age': 40 };
 8568:       *
 8569:       * _.omitBy(object, _.isNumber);
 8570:       * // => { 'user': 'fred' }
 8571:       */
 8572:          function omitBy(object, predicate) {
 8573:              predicate = getIteratee(predicate);
 8574:              return basePickBy(object, function (value, key, object) {
 8575:                  return !predicate(value, key, object);
 8576:              });
 8577:          }
*****

***** LODASH\RD\50.js
 8501:          /**
 8502:       * Creates an object composed of the picked `object` properties.
 8503:       *
***** LODASH\RD\ORIGINAL.JS
 8578:          /**
 8579:       * Creates a two dimensional array of the key-value pairs for `object`,
 8580:       * e.g. `[[key1, value1], [key2, value2]]`.
 8581:       *
*****

***** LODASH\RD\50.js
 8506:       * @category Object
 8507:       * @param {Object} object The source object.
 8508:       * @param {string|string[]} [props] The property names to pick, specified
 8509:       *  individually or in arrays.
 8510:       * @returns {Object} Returns the new object.
 8511:       * @example
***** LODASH\RD\ORIGINAL.JS
 8584:       * @category Object
 8585:       * @param {Object} object The object to query.
 8586:       * @returns {Array} Returns the new array of key-value pairs.
 8587:       * @example
*****

***** LODASH\RD\50.js
 8512:       *
 8513:       * var object = { 'user': 'fred', 'age': 40 };
 8514:       *
 8515:       * _.pick(object, 'user');
 8516:       * // => { 'user': 'fred' }
 8517:       */
 8518:          var pick = restParam(function (object, props) {
 8519:              return object == null ? {} : basePick(object, baseFlatten(props));
 8520:          });
 8521:          /**
 8522:       * Creates an object composed of the `object` properties `predicate` returns
 8523:       * truthy for. The predicate is invoked with three arguments: (value, key, object).
 8524:       *
***** LODASH\RD\ORIGINAL.JS
 8588:       *
 8589:       * _.pairs({ 'barney': 36, 'fred': 40 });
 8590:       * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 8591:       */
 8592:          function pairs(object) {
 8593:              object = Object(object);
 8594:              var index = -1, props = keys(object), length = props.length, result = Array(length);
 8595:              while (++index < length) {
 8596:                  var key = props[index];
 8597:                  result[index] = [
 8598:                      key,
 8599:                      object[key]
 8600:                  ];
 8601:              }
 8602:              return result;
 8603:          }
 8604:          /**
 8605:       * Creates an object composed of the picked `object` properties.
 8606:       *
*****

***** LODASH\RD\50.js
 8528:       * @param {Object} object The source object.
 8529:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8530:       * @returns {Object} Returns the new object.
***** LODASH\RD\ORIGINAL.JS
 8610:       * @param {Object} object The source object.
 8611:       * @param {string|string[]} [props] The property names to pick, specified
 8612:       *  individually or in arrays.
 8613:       * @returns {Object} Returns the new object.
*****

***** LODASH\RD\50.js
 8534:       *
 8535:       * _.pickBy(object, _.isString);
 8536:       * // => { 'user': 'fred' }
***** LODASH\RD\ORIGINAL.JS
 8617:       *
 8618:       * _.pick(object, 'user');
 8619:       * // => { 'user': 'fred' }
*****

***** LODASH\RD\50.js
 8537:       */
 8538:          function pickBy(object, predicate) {
 8539:              return object == null ? {} : basePickBy(object, getIteratee(predicate));
 8540:          }
 8541:          /**
 8542:       * This method is like `_.get` except that if the resolved value is a function
 8543:       * it's invoked with the `this` binding of its parent object and its result
 8544:       * is returned.
 8545:       *
***** LODASH\RD\ORIGINAL.JS
 8620:       */
 8621:          var pick = restParam(function (object, props) {
 8622:              return object == null ? {} : basePick(object, baseFlatten(props));
 8623:          });
 8624:          /**
 8625:       * Creates an object composed of the `object` properties `predicate` returns
 8626:       * truthy for. The predicate is invoked with three arguments: (value, key, object).
 8627:       *
*****

***** LODASH\RD\50.js
 8548:       * @category Object
 8549:       * @param {Object} object The object to query.
 8550:       * @param {Array|string} path The path of the property to resolve.
 8551:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8552:       * @returns {*} Returns the resolved value.
 8553:       * @example
***** LODASH\RD\ORIGINAL.JS
 8630:       * @category Object
 8631:       * @param {Object} object The source object.
 8632:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8633:       * @returns {Object} Returns the new object.
 8634:       * @example
*****

***** LODASH\RD\50.js
 8554:       *
 8555:       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
***** LODASH\RD\ORIGINAL.JS
 8635:       *
 8636:       * var object = { 'user': 'fred', 'age': 40 };
 8637:       *
 8638:       * _.pickBy(object, _.isString);
 8639:       * // => { 'user': 'fred' }
 8640:       */
 8641:          function pickBy(object, predicate) {
 8642:              return object == null ? {} : basePickBy(object, getIteratee(predicate));
 8643:          }
 8644:          /**
 8645:       * This method is like `_.get` except that if the resolved value is a function
 8646:       * it's invoked with the `this` binding of its parent object and its result
 8647:       * is returned.
 8648:       *
 8649:       * @static
 8650:       * @memberOf _
 8651:       * @category Object
 8652:       * @param {Object} object The object to query.
 8653:       * @param {Array|string} path The path of the property to resolve.
 8654:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8655:       * @returns {*} Returns the resolved value.
 8656:       * @example
 8657:       *
 8658:       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
*****

***** LODASH\RD\50.js
 9447:          function trimLeft(string, chars, guard) {
 9448:              var value;
 9449:              string = baseToString(string);
***** LODASH\RD\ORIGINAL.JS
 9550:          function trimLeft(string, chars, guard) {
 9551:              var value = string;
 9552:              string = baseToString(string);
*****

