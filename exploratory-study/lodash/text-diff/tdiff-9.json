Comparing files LODASH\RD\9.js and LODASH\RD\ORIGINAL.JS
***** LODASH\RD\9.js
  573:      }
  574:      function trimmedLeftIndex(string) {
***** LODASH\RD\ORIGINAL.JS
  573:      }
  574:      /**
  575:     * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
  576:     * character of `string`.
  577:     *
  578:     * @private
  579:     * @param {string} string The string to inspect.
  580:     * @returns {number} Returns the index of the first non-whitespace character.
  581:     */
  582:      function trimmedLeftIndex(string) {
*****

***** LODASH\RD\9.js
 3310:              return result || isLength(object && object.length) && isIndex(path, object.length) && (isArray(object) || isArgumen
 3311:  ts() || isString(object));
 3312:          }
***** LODASH\RD\ORIGINAL.JS
 3318:              return result || isLength(object && object.length) && isIndex(path, object.length) && (isArray(object) || isArgumen
 3319:  ts(object) || isString(object));
 3320:          }
*****

***** LODASH\RD\9.js
 3487:              }
 3488:              var data = getData(other);
***** LODASH\RD\ORIGINAL.JS
 3495:              }
 3496:              if (func === other) {
 3497:                  return true;
 3498:              }
 3499:              var data = getData(other);
*****

***** LODASH\RD\9.js
 3958:                  start = 0;
 3959:              }
***** LODASH\RD\ORIGINAL.JS
 3969:                  start = 0;
 3970:                  end = length;
 3971:              }
*****

***** LODASH\RD\9.js
 4176:                              var cache = caches[othIndex];
 4177:                              if ((cache ? cacheIndexOf(cache) : indexOf(arrays[othIndex], value, 0)) < 0) {
 4178:                                  continue outer;
***** LODASH\RD\ORIGINAL.JS
 4188:                              var cache = caches[othIndex];
 4189:                              if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
 4190:                                  continue outer;
*****

***** LODASH\RD\9.js
 4180:                          }
 4181:                          result.push(value);
***** LODASH\RD\ORIGINAL.JS
 4192:                          }
 4193:                          if (seen) {
 4194:                              seen.push(value);
 4195:                          }
 4196:                          result.push(value);
*****

***** LODASH\RD\9.js
 8061:          }
 8062:          function forIn(object, iteratee) {
 8063:              return object == null ? object : baseFor(object, toFunction(iteratee), keysIn);
 8064:          }
 8065:          /**
 8066:       * This method is like `_.forIn` except that it iterates over properties of
 8067:       * `object` in the opposite order.
 8068:       *
***** LODASH\RD\ORIGINAL.JS
 8076:          }
 8077:          /**
 8078:       * Iterates over own and inherited enumerable properties of an object invoking
 8079:       * `iteratee` for each property. The iteratee is invoked with three arguments:
 8080:       * (value, key, object). Iteratee functions may exit iteration early by explicitly
 8081:       * returning `false`.
 8082:       *
*****

***** LODASH\RD\9.js
 8083:       *
 8084:       * _.forInRight(new Foo, function(value, key) {
 8085:       *   console.log(key);
***** LODASH\RD\ORIGINAL.JS
 8097:       *
 8098:       * _.forIn(new Foo, function(value, key) {
 8099:       *   console.log(key);
*****

***** LODASH\RD\9.js
 8086:       * });
 8087:       * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'
 8088:       */
 8089:          function forInRight(object, iteratee) {
 8090:              return object == null ? object : baseForRight(object, toFunction(iteratee), keysIn);
 8091:          }
***** LODASH\RD\ORIGINAL.JS
 8100:       * });
 8101:       * // => logs 'a', 'b', then 'c' (iteration order is not guaranteed)
 8102:       */
 8103:          function forIn(object, iteratee) {
 8104:              return object == null ? object : baseFor(object, toFunction(iteratee), keysIn);
 8105:          }
*****

***** LODASH\RD\9.js
 8092:          /**
 8093:       * Iterates over own enumerable properties of an object invoking `iteratee`
 8094:       * for each property. The iteratee is invoked with three arguments:
 8095:       * (value, key, object). Iteratee functions may exit iteration early by
 8096:       * explicitly returning `false`.
 8097:       *
***** LODASH\RD\ORIGINAL.JS
 8106:          /**
 8107:       * This method is like `_.forIn` except that it iterates over properties of
 8108:       * `object` in the opposite order.
 8109:       *
*****

***** LODASH\RD\9.js
 8112:       *
 8113:       * _.forOwn(new Foo, function(value, key) {
 8114:       *   console.log(key);
***** LODASH\RD\ORIGINAL.JS
 8124:       *
 8125:       * _.forInRight(new Foo, function(value, key) {
 8126:       *   console.log(key);
*****

***** LODASH\RD\9.js
 8115:       * });
 8116:       * // => logs 'a' then 'b' (iteration order is not guaranteed)
 8117:       */
 8118:          function forOwn(object, iteratee) {
 8119:              return object && baseForOwn(object, toFunction(iteratee));
 8120:          }
***** LODASH\RD\ORIGINAL.JS
 8127:       * });
 8128:       * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'
 8129:       */
 8130:          function forInRight(object, iteratee) {
 8131:              return object == null ? object : baseForRight(object, toFunction(iteratee), keysIn);
 8132:          }
*****

***** LODASH\RD\9.js
 8121:          /**
 8122:       * This method is like `_.forOwn` except that it iterates over properties of
 8123:       * `object` in the opposite order.
 8124:       *
***** LODASH\RD\ORIGINAL.JS
 8133:          /**
 8134:       * Iterates over own enumerable properties of an object invoking `iteratee`
 8135:       * for each property. The iteratee is invoked with three arguments:
 8136:       * (value, key, object). Iteratee functions may exit iteration early by
 8137:       * explicitly returning `false`.
 8138:       *
*****

***** LODASH\RD\9.js
 8139:       *
 8140:       * _.forOwnRight(new Foo, function(value, key) {
 8141:       *   console.log(key);
***** LODASH\RD\ORIGINAL.JS
 8153:       *
 8154:       * _.forOwn(new Foo, function(value, key) {
 8155:       *   console.log(key);
*****

***** LODASH\RD\9.js
 8142:       * });
 8143:       * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'
 8144:       */
 8145:          function forOwnRight(object, iteratee) {
 8146:              return object && baseForOwnRight(object, toFunction(iteratee));
 8147:          }
***** LODASH\RD\ORIGINAL.JS
 8156:       * });
 8157:       * // => logs 'a' then 'b' (iteration order is not guaranteed)
 8158:       */
 8159:          function forOwn(object, iteratee) {
 8160:              return object && baseForOwn(object, toFunction(iteratee));
 8161:          }
*****

***** LODASH\RD\9.js
 8148:          /**
 8149:       * Creates an array of function property names from all enumerable properties,
 8150:       * own and inherited, of `object`.
 8151:       *
***** LODASH\RD\ORIGINAL.JS
 8162:          /**
 8163:       * This method is like `_.forOwn` except that it iterates over properties of
 8164:       * `object` in the opposite order.
 8165:       *
*****

***** LODASH\RD\9.js
 8154:       * @category Object
 8155:       * @param {Object} object The object to inspect.
 8156:       * @returns {Array} Returns the new array of property names.
 8157:       * @example
***** LODASH\RD\ORIGINAL.JS
 8168:       * @category Object
 8169:       * @param {Object} object The object to iterate over.
 8170:       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 8171:       * @returns {Object} Returns `object`.
 8172:       * @example
*****

***** LODASH\RD\9.js
 8158:       *
 8159:       * _.functions(_);
 8160:       * // => ['after', 'ary', 'assign', ...]
 8161:       */
 8162:          function functions(object) {
 8163:              return object == null ? [] : baseFunctions(object, keysIn(object));
 8164:          }
***** LODASH\RD\ORIGINAL.JS
 8173:       *
 8174:       * function Foo() {
 8175:       *   this.a = 1;
 8176:       *   this.b = 2;
 8177:       * }
 8178:       *
 8179:       * Foo.prototype.c = 3;
 8180:       *
 8181:       * _.forOwnRight(new Foo, function(value, key) {
 8182:       *   console.log(key);
 8183:       * });
 8184:       * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'
 8185:       */
 8186:          function forOwnRight(object, iteratee) {
 8187:              return object && baseForOwnRight(object, toFunction(iteratee));
 8188:          }
*****

***** LODASH\RD\9.js
 8165:          /**
 8166:       * Gets the value at `path` of `object`. If the resolved value is
 8167:       * `undefined` the `defaultValue` is used in its place.
 8168:       *
***** LODASH\RD\ORIGINAL.JS
 8189:          /**
 8190:       * Creates an array of function property names from all enumerable properties,
 8191:       * own and inherited, of `object`.
 8192:       *
*****

***** LODASH\RD\9.js
 8171:       * @category Object
 8172:       * @param {Object} object The object to query.
 8173:       * @param {Array|string} path The path of the property to get.
 8174:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8175:       * @returns {*} Returns the resolved value.
 8176:       * @example
***** LODASH\RD\ORIGINAL.JS
 8195:       * @category Object
 8196:       * @param {Object} object The object to inspect.
 8197:       * @returns {Array} Returns the new array of property names.
 8198:       * @example
*****

***** LODASH\RD\9.js
 8177:       *
 8178:       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 8179:       *
 8180:       * _.get(object, 'a[0].b.c');
 8181:       * // => 3
 8182:       *
 8183:       * _.get(object, ['a', '0', 'b', 'c']);
 8184:       * // => 3
 8185:       *
 8186:       * _.get(object, 'a.b.c', 'default');
 8187:       * // => 'default'
 8188:       */
 8189:          function get(object, path, defaultValue) {
 8190:              var result = object == null ? undefined : baseGet(object, path);
 8191:              return result === undefined ? defaultValue : result;
 8192:          }
***** LODASH\RD\ORIGINAL.JS
 8199:       *
 8200:       * _.functions(_);
 8201:       * // => ['after', 'ary', 'assign', ...]
 8202:       */
 8203:          function functions(object) {
 8204:              return object == null ? [] : baseFunctions(object, keysIn(object));
 8205:          }
*****

***** LODASH\RD\9.js
 8193:          /**
 8194:       * Checks if `path` is a direct property of `object`.
 8195:       *
***** LODASH\RD\ORIGINAL.JS
 8206:          /**
 8207:       * Gets the value at `path` of `object`. If the resolved value is
 8208:       * `undefined` the `defaultValue` is used in its place.
 8209:       *
*****

***** LODASH\RD\9.js
 8199:       * @param {Object} object The object to query.
 8200:       * @param {Array|string} path The path to check.
 8201:       * @returns {boolean} Returns `true` if `path` exists, else `false`.
 8202:       * @example
***** LODASH\RD\ORIGINAL.JS
 8213:       * @param {Object} object The object to query.
 8214:       * @param {Array|string} path The path of the property to get.
 8215:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8216:       * @returns {*} Returns the resolved value.
 8217:       * @example
*****

***** LODASH\RD\9.js
 8203:       *
 8204:       * var object = { 'a': { 'b': { 'c': 3 } } },
 8205:       *     other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 8206:       *
 8207:       * _.has(object, 'a');
 8208:       * // => true
 8209:       *
 8210:       * _.has(object, 'a.b.c');
 8211:       * // => true
 8212:       *
 8213:       * _.has(object, ['a', 'b', 'c']);
 8214:       * // => true
 8215:       *
 8216:       * _.has(other, 'a');
 8217:       * // => false
 8218:       */
 8219:          function has(object, path) {
 8220:              return hasPath(object, path, baseHas);
 8221:          }
***** LODASH\RD\ORIGINAL.JS
 8218:       *
 8219:       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 8220:       *
 8221:       * _.get(object, 'a[0].b.c');
 8222:       * // => 3
 8223:       *
 8224:       * _.get(object, ['a', '0', 'b', 'c']);
 8225:       * // => 3
 8226:       *
 8227:       * _.get(object, 'a.b.c', 'default');
 8228:       * // => 'default'
 8229:       */
 8230:          function get(object, path, defaultValue) {
 8231:              var result = object == null ? undefined : baseGet(object, path);
 8232:              return result === undefined ? defaultValue : result;
 8233:          }
*****

***** LODASH\RD\9.js
 8222:          /**
 8223:       * Checks if `path` is a direct or inherited property of `object`.
 8224:       *
***** LODASH\RD\ORIGINAL.JS
 8234:          /**
 8235:       * Checks if `path` is a direct property of `object`.
 8236:       *
*****

***** LODASH\RD\9.js
 8232:       *
 8233:       * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 8234:       *
 8235:       * _.hasIn(object, 'a');
 8236:       * // => true
***** LODASH\RD\ORIGINAL.JS
 8244:       *
 8245:       * var object = { 'a': { 'b': { 'c': 3 } } },
 8246:       *     other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 8247:       *
 8248:       * _.has(object, 'a');
 8249:       * // => true
*****

***** LODASH\RD\9.js
 8237:       *
 8238:       * _.hasIn(object, 'a.b.c');
 8239:       * // => true
***** LODASH\RD\ORIGINAL.JS
 8250:       *
 8251:       * _.has(object, 'a.b.c');
 8252:       * // => true
*****

***** LODASH\RD\9.js
 8240:       *
 8241:       * _.hasIn(object, ['a', 'b', 'c']);
 8242:       * // => true
***** LODASH\RD\ORIGINAL.JS
 8253:       *
 8254:       * _.has(object, ['a', 'b', 'c']);
 8255:       * // => true
*****

***** LODASH\RD\9.js
 8243:       *
 8244:       * _.hasIn(object, 'b');
 8245:       * // => false
***** LODASH\RD\ORIGINAL.JS
 8256:       *
 8257:       * _.has(other, 'a');
 8258:       * // => false
*****

***** LODASH\RD\9.js
 8246:       */
 8247:          function hasIn(object, path) {
 8248:              return hasPath(object, path, baseHasIn);
 8249:          }
***** LODASH\RD\ORIGINAL.JS
 8259:       */
 8260:          function has(object, path) {
 8261:              return hasPath(object, path, baseHas);
 8262:          }
*****

***** LODASH\RD\9.js
 8250:          /**
 8251:       * Creates an object composed of the inverted keys and values of `object`.
 8252:       * If `object` contains duplicate values, subsequent values overwrite property
 8253:       * assignments of previous values unless `multiValue` is `true`.
 8254:       *
***** LODASH\RD\ORIGINAL.JS
 8263:          /**
 8264:       * Checks if `path` is a direct or inherited property of `object`.
 8265:       *
*****

***** LODASH\RD\9.js
 8257:       * @category Object
 8258:       * @param {Object} object The object to invert.
 8259:       * @param {boolean} [multiValue] Allow multiple values per key.
 8260:       * @returns {Object} Returns the new inverted object.
 8261:       * @example
***** LODASH\RD\ORIGINAL.JS
 8268:       * @category Object
 8269:       * @param {Object} object The object to query.
 8270:       * @param {Array|string} path The path to check.
 8271:       * @returns {boolean} Returns `true` if `path` exists, else `false`.
 8272:       * @example
*****

***** LODASH\RD\9.js
 8262:       *
 8263:       * var object = { 'a': 1, 'b': 2, 'c': 1 };
 8264:       *
 8265:       * _.invert(object);
 8266:       * // => { '1': 'c', '2': 'b' }
 8267:       *
 8268:       * // with `multiValue`
 8269:       * _.invert(object, true);
 8270:       * // => { '1': ['a', 'c'], '2': ['b'] }
 8271:       */
 8272:          function invert(object, multiValue) {
 8273:              multiValue = typeof multiValue == 'boolean' && multiValue;
 8274:              var index = -1, props = keys(object), length = props.length, result = {};
 8275:              while (++index < length) {
 8276:                  var key = props[index], value = object[key];
 8277:                  if (multiValue) {
 8278:                      if (hasOwnProperty.call(result, value)) {
 8279:                          result[value].push(key);
 8280:                      } else {
 8281:                          result[value] = [key];
 8282:                      }
 8283:                  } else {
 8284:                      result[value] = key;
 8285:                  }
 8286:              }
 8287:              return result;
 8288:          }
***** LODASH\RD\ORIGINAL.JS
 8273:       *
 8274:       * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
 8275:       *
 8276:       * _.hasIn(object, 'a');
 8277:       * // => true
 8278:       *
 8279:       * _.hasIn(object, 'a.b.c');
 8280:       * // => true
 8281:       *
 8282:       * _.hasIn(object, ['a', 'b', 'c']);
 8283:       * // => true
 8284:       *
 8285:       * _.hasIn(object, 'b');
 8286:       * // => false
 8287:       */
 8288:          function hasIn(object, path) {
 8289:              return hasPath(object, path, baseHasIn);
 8290:          }
*****

***** LODASH\RD\9.js
 8289:          /**
 8290:       * Creates an array of the own enumerable property names of `object`.
 8291:       *
 8292:       * **Note:** Non-object values are coerced to objects. See the
 8293:       * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 8294:       * for more details.
 8295:       *
***** LODASH\RD\ORIGINAL.JS
 8291:          /**
 8292:       * Creates an object composed of the inverted keys and values of `object`.
 8293:       * If `object` contains duplicate values, subsequent values overwrite property
 8294:       * assignments of previous values unless `multiValue` is `true`.
 8295:       *
*****

***** LODASH\RD\9.js
 8298:       * @category Object
 8299:       * @param {Object} object The object to query.
 8300:       * @returns {Array} Returns the array of property names.
 8301:       * @example
***** LODASH\RD\ORIGINAL.JS
 8298:       * @category Object
 8299:       * @param {Object} object The object to invert.
 8300:       * @param {boolean} [multiValue] Allow multiple values per key.
 8301:       * @returns {Object} Returns the new inverted object.
 8302:       * @example
*****

***** LODASH\RD\9.js
 8302:       *
 8303:       * function Foo() {
 8304:       *   this.a = 1;
 8305:       *   this.b = 2;
 8306:       * }
 8307:       *
 8308:       * Foo.prototype.c = 3;
 8309:       *
 8310:       * _.keys(new Foo);
 8311:       * // => ['a', 'b'] (iteration order is not guaranteed)
 8312:       *
 8313:       * _.keys('hi');
 8314:       * // => ['0', '1']
 8315:       */
 8316:          function keys(object) {
 8317:              object = Object(object);
 8318:              var isProto = isPrototype(object);
 8319:              if (!(isProto || isArrayLike(object))) {
 8320:                  return nativeKeys(object);
 8321:              }
 8322:              var result = initKeys(object), length = result.length, skipIndexes = !!length;
 8323:              for (var key in object) {
 8324:                  if (hasOwnProperty.call(object, key) && !(skipIndexes && isIndex(key, length)) && !(isProto && key == 'construc
 8325:  tor')) {
 8326:                      result.push(key);
 8327:                  }
***** LODASH\RD\ORIGINAL.JS
 8303:       *
 8304:       * var object = { 'a': 1, 'b': 2, 'c': 1 };
 8305:       *
 8306:       * _.invert(object);
 8307:       * // => { '1': 'c', '2': 'b' }
 8308:       *
 8309:       * // with `multiValue`
 8310:       * _.invert(object, true);
 8311:       * // => { '1': ['a', 'c'], '2': ['b'] }
 8312:       */
 8313:          function invert(object, multiValue) {
 8314:              multiValue = typeof multiValue == 'boolean' && multiValue;
 8315:              var index = -1, props = keys(object), length = props.length, result = {};
 8316:              while (++index < length) {
 8317:                  var key = props[index], value = object[key];
 8318:                  if (multiValue) {
 8319:                      if (hasOwnProperty.call(result, value)) {
 8320:                          result[value].push(key);
 8321:                      } else {
 8322:                          result[value] = [key];
 8323:                      }
 8324:                  } else {
 8325:                      result[value] = key;
 8326:                  }
*****

***** LODASH\RD\9.js
 8331:          /**
 8332:       * Creates an array of the own and inherited enumerable property names of `object`.
 8333:       *
 8334:       * **Note:** Non-object values are coerced to objects.
 8335:       *
***** LODASH\RD\ORIGINAL.JS
 8330:          /**
 8331:       * Creates an array of the own enumerable property names of `object`.
 8332:       *
 8333:       * **Note:** Non-object values are coerced to objects. See the
 8334:       * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 8335:       * for more details.
 8336:       *
*****

***** LODASH\RD\9.js
 8349:       *
 8350:       * _.keysIn(new Foo);
 8351:       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 8352:       */
 8353:          function keysIn(object) {
 8354:              object = Object(object);
 8355:              var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, result = ini
 8356:  tKeys(object), length = result.length, skipIndexes = !!length;
 8357:              while (++index < propsLength) {
 8358:                  var key = props[index];
 8359:                  if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object
 8360:  , key)))) {
 8361:                      result.push(key);
***** LODASH\RD\ORIGINAL.JS
 8350:       *
 8351:       * _.keys(new Foo);
 8352:       * // => ['a', 'b'] (iteration order is not guaranteed)
 8353:       *
 8354:       * _.keys('hi');
 8355:       * // => ['0', '1']
 8356:       */
 8357:          function keys(object) {
 8358:              object = Object(object);
 8359:              var isProto = isPrototype(object);
 8360:              if (!(isProto || isArrayLike(object))) {
 8361:                  return nativeKeys(object);
 8362:              }
 8363:              var result = initKeys(object), length = result.length, skipIndexes = !!length;
 8364:              for (var key in object) {
 8365:                  if (hasOwnProperty.call(object, key) && !(skipIndexes && isIndex(key, length)) && !(isProto && key == 'construc
 8366:  tor')) {
 8367:                      result.push(key);
*****

***** LODASH\RD\9.js
 8366:          /**
 8367:       * The opposite of `_.mapValues`; this method creates an object with the
 8368:       * same values as `object` and keys generated by running each own enumerable
 8369:       * property of `object` through `iteratee`.
 8370:       *
***** LODASH\RD\ORIGINAL.JS
 8372:          /**
 8373:       * Creates an array of the own and inherited enumerable property names of `object`.
 8374:       *
 8375:       * **Note:** Non-object values are coerced to objects.
 8376:       *
*****

***** LODASH\RD\9.js
 8373:       * @category Object
 8374:       * @param {Object} object The object to iterate over.
 8375:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 8376:       * @returns {Object} Returns the new mapped object.
 8377:       * @example
***** LODASH\RD\ORIGINAL.JS
 8379:       * @category Object
 8380:       * @param {Object} object The object to query.
 8381:       * @returns {Array} Returns the array of property names.
 8382:       * @example
*****

***** LODASH\RD\9.js
 8378:       *
 8379:       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 8380:       *   return key + value;
 8381:       * });
 8382:       * // => { 'a1': 1, 'b2': 2 }
 8383:       */
 8384:          function mapKeys(object, iteratee) {
 8385:              var result = {};
 8386:              iteratee = getIteratee(iteratee);
 8387:              baseForOwn(object, function (value, key, object) {
 8388:                  result[iteratee(value, key, object)] = value;
 8389:              });
 8390:              return result;
***** LODASH\RD\ORIGINAL.JS
 8383:       *
 8384:       * function Foo() {
 8385:       *   this.a = 1;
 8386:       *   this.b = 2;
 8387:       * }
 8388:       *
 8389:       * Foo.prototype.c = 3;
 8390:       *
 8391:       * _.keysIn(new Foo);
 8392:       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 8393:       */
 8394:          function keysIn(object) {
 8395:              object = Object(object);
 8396:              var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, result = ini
 8397:  tKeys(object), length = result.length, skipIndexes = !!length;
 8398:              while (++index < propsLength) {
 8399:                  var key = props[index];
 8400:                  if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object
 8401:  , key)))) {
 8402:                      result.push(key);
 8403:                  }
 8404:              }
 8405:              return result;
*****

***** LODASH\RD\9.js
 8392:          /**
 8393:       * Creates an object with the same keys as `object` and values generated by
 8394:       * running each own enumerable property of `object` through `iteratee`. The
 8395:       * iteratee function is invoked with three arguments: (value, key, object).
 8396:       *
***** LODASH\RD\ORIGINAL.JS
 8407:          /**
 8408:       * The opposite of `_.mapValues`; this method creates an object with the
 8409:       * same values as `object` and keys generated by running each own enumerable
 8410:       * property of `object` through `iteratee`.
 8411:       *
*****

***** LODASH\RD\9.js
 8404:       *
 8405:       * var users = {
 8406:       *   'fred':    { 'user': 'fred',    'age': 40 },
 8407:       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 8408:       * };
 8409:       *
 8410:       * _.mapValues(users, function(o) { return o.age; });
 8411:       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 8412:       *
 8413:       * // using the `_.property` callback shorthand
 8414:       * _.mapValues(users, 'age');
 8415:       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 8416:       */
 8417:          function mapValues(object, iteratee) {
 8418:              var result = {};
***** LODASH\RD\ORIGINAL.JS
 8419:       *
 8420:       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 8421:       *   return key + value;
 8422:       * });
 8423:       * // => { 'a1': 1, 'b2': 2 }
 8424:       */
 8425:          function mapKeys(object, iteratee) {
 8426:              var result = {};
*****

***** LODASH\RD\9.js
 8420:              baseForOwn(object, function (value, key, object) {
 8421:                  result[key] = iteratee(value, key, object);
 8422:              });
***** LODASH\RD\ORIGINAL.JS
 8428:              baseForOwn(object, function (value, key, object) {
 8429:                  result[iteratee(value, key, object)] = value;
 8430:              });
*****

***** LODASH\RD\9.js
 8425:          /**
 8426:       * Recursively merges own enumerable properties of the source object(s) into the
 8427:       * destination object, for source properties which don't resolve to `undefined`.
 8428:       * Subsequent sources overwrite property assignments of previous sources.
 8429:       *
***** LODASH\RD\ORIGINAL.JS
 8433:          /**
 8434:       * Creates an object with the same keys as `object` and values generated by
 8435:       * running each own enumerable property of `object` through `iteratee`. The
 8436:       * iteratee function is invoked with three arguments: (value, key, object).
 8437:       *
*****

***** LODASH\RD\9.js
 8432:       * @category Object
 8433:       * @param {Object} object The destination object.
 8434:       * @param {...Object} [sources] The source objects.
 8435:       * @returns {Object} Returns `object`.
 8436:       * @example
***** LODASH\RD\ORIGINAL.JS
 8440:       * @category Object
 8441:       * @param {Object} object The object to iterate over.
 8442:       * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
 8443:       * @returns {Object} Returns the new mapped object.
 8444:       * @example
*****

***** LODASH\RD\9.js
 8438:       * var users = {
 8439:       *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 8440:       * };
***** LODASH\RD\ORIGINAL.JS
 8446:       * var users = {
 8447:       *   'fred':    { 'user': 'fred',    'age': 40 },
 8448:       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 8449:       * };
*****

***** LODASH\RD\9.js
 8441:       *
 8442:       * var ages = {
 8443:       *   'data': [{ 'age': 36 }, { 'age': 40 }]
 8444:       * };
 8445:       *
 8446:       * _.merge(users, ages);
 8447:       * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 8448:       */
 8449:          var merge = createAssigner(function (object, source) {
 8450:              baseMerge(object, source);
 8451:          });
 8452:          /**
 8453:       * This method is like `_.merge` except that it accepts `customizer` which
 8454:       * is invoked to produce the merged values of the destination and source
 8455:       * properties. If `customizer` returns `undefined` merging is handled by the
 8456:       * method instead. The `customizer` is invoked with seven arguments:
 8457:       * (objValue, srcValue, key, object, source, stackA, stackB).
 8458:       *
***** LODASH\RD\ORIGINAL.JS
 8450:       *
 8451:       * _.mapValues(users, function(o) { return o.age; });
 8452:       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 8453:       *
 8454:       * // using the `_.property` callback shorthand
 8455:       * _.mapValues(users, 'age');
 8456:       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 8457:       */
 8458:          function mapValues(object, iteratee) {
 8459:              var result = {};
 8460:              iteratee = getIteratee(iteratee);
 8461:              baseForOwn(object, function (value, key, object) {
 8462:                  result[key] = iteratee(value, key, object);
 8463:              });
 8464:              return result;
 8465:          }
 8466:          /**
 8467:       * Recursively merges own enumerable properties of the source object(s) into the
 8468:       * destination object, for source properties which don't resolve to `undefined`.
 8469:       * Subsequent sources overwrite property assignments of previous sources.
 8470:       *
*****

***** LODASH\RD\9.js
 8462:       * @param {Object} object The destination object.
 8463:       * @param {...Object} sources The source objects.
 8464:       * @param {Function} customizer The function to customize assigned values.
 8465:       * @returns {Object} Returns `object`.
***** LODASH\RD\ORIGINAL.JS
 8474:       * @param {Object} object The destination object.
 8475:       * @param {...Object} [sources] The source objects.
 8476:       * @returns {Object} Returns `object`.
*****

***** LODASH\RD\9.js
 8467:       *
 8468:       * var object = {
 8469:       *   'fruits': ['apple'],
 8470:       *   'vegetables': ['beet']
 8471:       * };
***** LODASH\RD\ORIGINAL.JS
 8478:       *
 8479:       * var users = {
 8480:       *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 8481:       * };
*****

***** LODASH\RD\9.js
 8472:       *
 8473:       * var other = {
 8474:       *   'fruits': ['banana'],
 8475:       *   'vegetables': ['carrot']
 8476:       * };
***** LODASH\RD\ORIGINAL.JS
 8482:       *
 8483:       * var ages = {
 8484:       *   'data': [{ 'age': 36 }, { 'age': 40 }]
 8485:       * };
*****

***** LODASH\RD\9.js
 8477:       *
 8478:       * _.mergeWith(object, other, function(a, b) {
 8479:       *   if (_.isArray(a)) {
 8480:       *     return a.concat(b);
 8481:       *   }
 8482:       * });
 8483:       * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 8484:       */
 8485:          var mergeWith = createAssigner(function (object, source, customizer) {
 8486:              baseMerge(object, source, customizer);
 8487:          });
***** LODASH\RD\ORIGINAL.JS
 8486:       *
 8487:       * _.merge(users, ages);
 8488:       * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 8489:       */
 8490:          var merge = createAssigner(function (object, source) {
 8491:              baseMerge(object, source);
 8492:          });
*****

***** LODASH\RD\9.js
 8488:          /**
 8489:       * The opposite of `_.pick`; this method creates an object composed of the
 8490:       * own and inherited enumerable properties of `object` that are not omitted.
 8491:       *
***** LODASH\RD\ORIGINAL.JS
 8493:          /**
 8494:       * This method is like `_.merge` except that it accepts `customizer` which
 8495:       * is invoked to produce the merged values of the destination and source
 8496:       * properties. If `customizer` returns `undefined` merging is handled by the
 8497:       * method instead. The `customizer` is invoked with seven arguments:
 8498:       * (objValue, srcValue, key, object, source, stackA, stackB).
 8499:       *
*****

***** LODASH\RD\9.js
 8494:       * @category Object
 8495:       * @param {Object} object The source object.
 8496:       * @param {string|string[]} [props] The property names to omit, specified
 8497:       *  individually or in arrays..
 8498:       * @returns {Object} Returns the new object.
 8499:       * @example
***** LODASH\RD\ORIGINAL.JS
 8502:       * @category Object
 8503:       * @param {Object} object The destination object.
 8504:       * @param {...Object} sources The source objects.
 8505:       * @param {Function} customizer The function to customize assigned values.
 8506:       * @returns {Object} Returns `object`.
 8507:       * @example
*****

***** LODASH\RD\9.js
 8500:       *
 8501:       * var object = { 'user': 'fred', 'age': 40 };
 8502:       *
 8503:       * _.omit(object, 'age');
 8504:       * // => { 'user': 'fred' }
 8505:       */
 8506:          var omit = restParam(function (object, props) {
 8507:              if (object == null) {
 8508:                  return {};
 8509:              }
 8510:              props = arrayMap(baseFlatten(props), String);
 8511:              return basePick(object, baseDifference(keysIn(object), props));
 8512:          });
***** LODASH\RD\ORIGINAL.JS
 8508:       *
 8509:       * var object = {
 8510:       *   'fruits': ['apple'],
 8511:       *   'vegetables': ['beet']
 8512:       * };
 8513:       *
 8514:       * var other = {
 8515:       *   'fruits': ['banana'],
 8516:       *   'vegetables': ['carrot']
 8517:       * };
 8518:       *
 8519:       * _.mergeWith(object, other, function(a, b) {
 8520:       *   if (_.isArray(a)) {
 8521:       *     return a.concat(b);
 8522:       *   }
 8523:       * });
 8524:       * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 8525:       */
 8526:          var mergeWith = createAssigner(function (object, source, customizer) {
 8527:              baseMerge(object, source, customizer);
 8528:          });
*****

***** LODASH\RD\9.js
 8513:          /**
 8514:       * The opposite of `_.pickBy`; this method creates an object composed of the
 8515:       * own and inherited enumerable properties of `object` that `predicate`
 8516:       * doesn't return truthy for.
 8517:       *
***** LODASH\RD\ORIGINAL.JS
 8529:          /**
 8530:       * The opposite of `_.pick`; this method creates an object composed of the
 8531:       * own and inherited enumerable properties of `object` that are not omitted.
 8532:       *
*****

***** LODASH\RD\9.js
 8521:       * @param {Object} object The source object.
 8522:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8523:       * @returns {Object} Returns the new object.
***** LODASH\RD\ORIGINAL.JS
 8536:       * @param {Object} object The source object.
 8537:       * @param {string|string[]} [props] The property names to omit, specified
 8538:       *  individually or in arrays..
 8539:       * @returns {Object} Returns the new object.
*****

***** LODASH\RD\9.js
 8527:       *
 8528:       * _.omitBy(object, _.isNumber);
 8529:       * // => { 'user': 'fred' }
***** LODASH\RD\ORIGINAL.JS
 8543:       *
 8544:       * _.omit(object, 'age');
 8545:       * // => { 'user': 'fred' }
*****

***** LODASH\RD\9.js
 8530:       */
 8531:          function omitBy(object, predicate) {
 8532:              predicate = getIteratee(predicate);
 8533:              return basePickBy(object, function (value, key, object) {
 8534:                  return !predicate(value, key, object);
 8535:              });
 8536:          }
 8537:          /**
 8538:       * Creates a two dimensional array of the key-value pairs for `object`,
 8539:       * e.g. `[[key1, value1], [key2, value2]]`.
 8540:       *
***** LODASH\RD\ORIGINAL.JS
 8546:       */
 8547:          var omit = restParam(function (object, props) {
 8548:              if (object == null) {
 8549:                  return {};
 8550:              }
 8551:              props = arrayMap(baseFlatten(props), String);
 8552:              return basePick(object, baseDifference(keysIn(object), props));
 8553:          });
 8554:          /**
 8555:       * The opposite of `_.pickBy`; this method creates an object composed of the
 8556:       * own and inherited enumerable properties of `object` that `predicate`
 8557:       * doesn't return truthy for.
 8558:       *
*****

***** LODASH\RD\9.js
 8543:       * @category Object
 8544:       * @param {Object} object The object to query.
 8545:       * @returns {Array} Returns the new array of key-value pairs.
 8546:       * @example
***** LODASH\RD\ORIGINAL.JS
 8561:       * @category Object
 8562:       * @param {Object} object The source object.
 8563:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8564:       * @returns {Object} Returns the new object.
 8565:       * @example
*****

***** LODASH\RD\9.js
 8547:       *
 8548:       * _.pairs({ 'barney': 36, 'fred': 40 });
 8549:       * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 8550:       */
 8551:          function pairs(object) {
 8552:              object = Object(object);
 8553:              var index = -1, props = keys(object), length = props.length, result = Array(length);
 8554:              while (++index < length) {
 8555:                  var key = props[index];
 8556:                  result[index] = [
 8557:                      key,
 8558:                      object[key]
 8559:                  ];
 8560:              }
 8561:              return result;
 8562:          }
***** LODASH\RD\ORIGINAL.JS
 8566:       *
 8567:       * var object = { 'user': 'fred', 'age': 40 };
 8568:       *
 8569:       * _.omitBy(object, _.isNumber);
 8570:       * // => { 'user': 'fred' }
 8571:       */
 8572:          function omitBy(object, predicate) {
 8573:              predicate = getIteratee(predicate);
 8574:              return basePickBy(object, function (value, key, object) {
 8575:                  return !predicate(value, key, object);
 8576:              });
 8577:          }
*****

***** LODASH\RD\9.js
 8563:          /**
 8564:       * Creates an object composed of the picked `object` properties.
 8565:       *
***** LODASH\RD\ORIGINAL.JS
 8578:          /**
 8579:       * Creates a two dimensional array of the key-value pairs for `object`,
 8580:       * e.g. `[[key1, value1], [key2, value2]]`.
 8581:       *
*****

***** LODASH\RD\9.js
 8568:       * @category Object
 8569:       * @param {Object} object The source object.
 8570:       * @param {string|string[]} [props] The property names to pick, specified
 8571:       *  individually or in arrays.
 8572:       * @returns {Object} Returns the new object.
 8573:       * @example
***** LODASH\RD\ORIGINAL.JS
 8584:       * @category Object
 8585:       * @param {Object} object The object to query.
 8586:       * @returns {Array} Returns the new array of key-value pairs.
 8587:       * @example
*****

***** LODASH\RD\9.js
 8574:       *
 8575:       * var object = { 'user': 'fred', 'age': 40 };
 8576:       *
 8577:       * _.pick(object, 'user');
 8578:       * // => { 'user': 'fred' }
 8579:       */
 8580:          var pick = restParam(function (object, props) {
 8581:              return object == null ? {} : basePick(object, baseFlatten(props));
 8582:          });
 8583:          /**
 8584:       * Creates an object composed of the `object` properties `predicate` returns
 8585:       * truthy for. The predicate is invoked with three arguments: (value, key, object).
 8586:       *
***** LODASH\RD\ORIGINAL.JS
 8588:       *
 8589:       * _.pairs({ 'barney': 36, 'fred': 40 });
 8590:       * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 8591:       */
 8592:          function pairs(object) {
 8593:              object = Object(object);
 8594:              var index = -1, props = keys(object), length = props.length, result = Array(length);
 8595:              while (++index < length) {
 8596:                  var key = props[index];
 8597:                  result[index] = [
 8598:                      key,
 8599:                      object[key]
 8600:                  ];
 8601:              }
 8602:              return result;
 8603:          }
 8604:          /**
 8605:       * Creates an object composed of the picked `object` properties.
 8606:       *
*****

***** LODASH\RD\9.js
 8590:       * @param {Object} object The source object.
 8591:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8592:       * @returns {Object} Returns the new object.
***** LODASH\RD\ORIGINAL.JS
 8610:       * @param {Object} object The source object.
 8611:       * @param {string|string[]} [props] The property names to pick, specified
 8612:       *  individually or in arrays.
 8613:       * @returns {Object} Returns the new object.
*****

***** LODASH\RD\9.js
 8596:       *
 8597:       * _.pickBy(object, _.isString);
 8598:       * // => { 'user': 'fred' }
***** LODASH\RD\ORIGINAL.JS
 8617:       *
 8618:       * _.pick(object, 'user');
 8619:       * // => { 'user': 'fred' }
*****

***** LODASH\RD\9.js
 8599:       */
 8600:          function pickBy(object, predicate) {
 8601:              return object == null ? {} : basePickBy(object, getIteratee(predicate));
 8602:          }
 8603:          /**
 8604:       * This method is like `_.get` except that if the resolved value is a function
 8605:       * it's invoked with the `this` binding of its parent object and its result
 8606:       * is returned.
 8607:       *
***** LODASH\RD\ORIGINAL.JS
 8620:       */
 8621:          var pick = restParam(function (object, props) {
 8622:              return object == null ? {} : basePick(object, baseFlatten(props));
 8623:          });
 8624:          /**
 8625:       * Creates an object composed of the `object` properties `predicate` returns
 8626:       * truthy for. The predicate is invoked with three arguments: (value, key, object).
 8627:       *
*****

***** LODASH\RD\9.js
 8610:       * @category Object
 8611:       * @param {Object} object The object to query.
 8612:       * @param {Array|string} path The path of the property to resolve.
 8613:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8614:       * @returns {*} Returns the resolved value.
 8615:       * @example
***** LODASH\RD\ORIGINAL.JS
 8630:       * @category Object
 8631:       * @param {Object} object The source object.
 8632:       * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
 8633:       * @returns {Object} Returns the new object.
 8634:       * @example
*****

***** LODASH\RD\9.js
 8616:       *
 8617:       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
***** LODASH\RD\ORIGINAL.JS
 8635:       *
 8636:       * var object = { 'user': 'fred', 'age': 40 };
 8637:       *
 8638:       * _.pickBy(object, _.isString);
 8639:       * // => { 'user': 'fred' }
 8640:       */
 8641:          function pickBy(object, predicate) {
 8642:              return object == null ? {} : basePickBy(object, getIteratee(predicate));
 8643:          }
 8644:          /**
 8645:       * This method is like `_.get` except that if the resolved value is a function
 8646:       * it's invoked with the `this` binding of its parent object and its result
 8647:       * is returned.
 8648:       *
 8649:       * @static
 8650:       * @memberOf _
 8651:       * @category Object
 8652:       * @param {Object} object The object to query.
 8653:       * @param {Array|string} path The path of the property to resolve.
 8654:       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
 8655:       * @returns {*} Returns the resolved value.
 8656:       * @example
 8657:       *
 8658:       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
*****

***** LODASH\RD\9.js
10653:                  }
10654:                  n = n == null ? 1 : nativeMax(toInteger(n));
10655:                  var result = this.clone();
***** LODASH\RD\ORIGINAL.JS
10694:                  }
10695:                  n = n == null ? 1 : nativeMax(toInteger(n), 0);
10696:                  var result = this.clone();
*****

