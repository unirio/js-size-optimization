Comparando os arquivos HC\0.js e HC\ORIGINAL.JS
***** HC\0.js
   12:      // Save bytes in the minified (but not gzipped) version:
   13:      var ArrayProto = Array.prototype, FuncProto = Function.prototype;
   14:      // Create quick reference variables for speed access to core prototypes.
   15:      var push = ArrayProto.push, slice = ArrayProto.slice;
   16:      // All **ECMAScript 5** native function implementations that we hope to use
***** HC\ORIGINAL.JS
   12:      // Save bytes in the minified (but not gzipped) version:
   13:      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
   14:      // Create quick reference variables for speed access to core prototypes.
   15:      var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnPropert
   16:  y;
   17:      // All **ECMAScript 5** native function implementations that we hope to use
*****

***** HC\0.js
   17:      // are declared here.
   18:      var nativeIsArray = Array.isArray, nativeBind = FuncProto.bind, nativeCreate = Object.create;
   19:      // Naked function reference for surrogate-prototype-swapping.
   20:      var Ctor;
   21:      // Create a safe reference to the Underscore object for use below.
***** HC\ORIGINAL.JS
   18:      // are declared here.
   19:      var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
   20:      // Naked function reference for surrogate-prototype-swapping.
   21:      var Ctor = function () {
   22:      };
   23:      // Create a safe reference to the Underscore object for use below.
*****

***** HC\0.js
   32:      if (typeof exports !== 'undefined') {
   33:      } else {
***** HC\ORIGINAL.JS
   34:      if (typeof exports !== 'undefined') {
   35:          if (typeof module !== 'undefined' && module.exports) {
   36:              exports = module.exports = _;
   37:          }
   38:          exports._ = _;
   39:      } else {
*****

***** HC\0.js
   35:      }
   36:      // Internal function that returns an efficient (for current engines) version
***** HC\ORIGINAL.JS
   41:      }
   42:      // Current version.
   43:      _.VERSION = '1.8.3';
   44:      // Internal function that returns an efficient (for current engines) version
*****

***** HC\0.js
   39:      var optimizeCb = function (func, context, argCount) {
   40:          switch (argCount == null ? 3 : argCount) {
***** HC\ORIGINAL.JS
   47:      var optimizeCb = function (func, context, argCount) {
   48:          if (context === void 0)
   49:              return func;
   50:          switch (argCount == null ? 3 : argCount) {
*****

***** HC\0.js
   41:          case 1:
   42:          case 2:
   43:          case 3:
   44:          case 4:
   45:          }
***** HC\ORIGINAL.JS
   51:          case 1:
   52:              return function (value) {
   53:                  return func.call(context, value);
   54:              };
   55:          case 2:
   56:              return function (value, other) {
   57:                  return func.call(context, value, other);
   58:              };
   59:          case 3:
   60:              return function (value, index, collection) {
   61:                  return func.call(context, value, index, collection);
   62:              };
   63:          case 4:
   64:              return function (accumulator, value, index, collection) {
   65:                  return func.call(context, accumulator, value, index, collection);
   66:              };
   67:          }
*****

***** HC\0.js
   87:              return nativeCreate(prototype);
   88:          var result = new Ctor();
   89:      };
***** HC\ORIGINAL.JS
  109:              return nativeCreate(prototype);
  110:          Ctor.prototype = prototype;
  111:          var result = new Ctor();
  112:          Ctor.prototype = null;
  113:          return result;
  114:      };
*****

***** HC\0.js
  245:      _.max = function (obj, iteratee, context) {
  246:          var result = -Infinity, lastComputed = -Infinity;
  247:          if (iteratee == null && obj != null) {
  248:              for (var i = 0, length = obj.length; i < length; i++) {
***** HC\ORIGINAL.JS
  270:      _.max = function (obj, iteratee, context) {
  271:          var result = -Infinity, lastComputed = -Infinity, value, computed;
  272:          if (iteratee == null && obj != null) {
  273:              obj = isArrayLike(obj) ? obj : _.values(obj);
  274:              for (var i = 0, length = obj.length; i < length; i++) {
*****

***** HC\0.js
  267:      _.min = function (obj, iteratee, context) {
  268:          var result = Infinity, lastComputed = Infinity;
  269:          if (iteratee == null && obj != null) {
  270:              for (var i = 0, length = obj.length; i < length; i++) {
***** HC\ORIGINAL.JS
  293:      _.min = function (obj, iteratee, context) {
  294:          var result = Infinity, lastComputed = Infinity, value, computed;
  295:          if (iteratee == null && obj != null) {
  296:              obj = isArrayLike(obj) ? obj : _.values(obj);
  297:              for (var i = 0, length = obj.length; i < length; i++) {
*****

***** HC\0.js
  293:          var shuffled = Array(length);
  294:          for (var index = 0; index < length; index++) {
  295:              rand = _.random(0, index);
***** HC\ORIGINAL.JS
  320:          var shuffled = Array(length);
  321:          for (var index = 0, rand; index < length; index++) {
  322:              rand = _.random(0, index);
*****

***** HC\0.js
  318:                  value: value,
  319:                  criteria: iteratee(value, index, list)
***** HC\ORIGINAL.JS
  345:                  value: value,
  346:                  index: index,
  347:                  criteria: iteratee(value, index, list)
*****

***** HC\0.js
  324:              if (a !== b) {
  325:                  if (a < b || b === void 0)
***** HC\ORIGINAL.JS
  352:              if (a !== b) {
  353:                  if (a > b || a === void 0)
  354:                      return 1;
  355:                  if (a < b || b === void 0)
*****

***** HC\0.js
  327:              }
  328:          }), 'value');
***** HC\ORIGINAL.JS
  357:              }
  358:              return left.index - right.index;
  359:          }), 'value');
*****

***** HC\0.js
  365:      _.toArray = function (obj) {
  366:          if (isArrayLike(obj))
***** HC\ORIGINAL.JS
  396:      _.toArray = function (obj) {
  397:          if (!obj)
  398:              return [];
  399:          if (_.isArray(obj))
  400:              return slice.call(obj);
  401:          if (isArrayLike(obj))
*****

***** HC\0.js
  371:      _.size = function (obj) {
  372:          return isArrayLike(obj) ? obj.length : _.keys(obj).length;
***** HC\ORIGINAL.JS
  406:      _.size = function (obj) {
  407:          if (obj == null)
  408:              return 0;
  409:          return isArrayLike(obj) ? obj.length : _.keys(obj).length;
*****

***** HC\0.js
  433:                  var j = 0, len = value.length;
  434:                  while (j < len) {
***** HC\ORIGINAL.JS
  470:                  var j = 0, len = value.length;
  471:                  output.length += len;
  472:                  while (j < len) {
*****

***** HC\0.js
  494:                  continue;
  495:              for (var j = 1;; j++) {
  496:                  if (!_.contains(arguments[j], item))
***** HC\ORIGINAL.JS
  532:                  continue;
  533:              for (var j = 1; j < argsLength; j++) {
  534:                  if (!_.contains(arguments[j], item))
*****

***** HC\0.js
  627:          var result = sourceFunc.apply(self, args);
  628:          return self;
***** HC\ORIGINAL.JS
  665:          var result = sourceFunc.apply(self, args);
  666:          if (_.isObject(result))
  667:              return result;
  668:          return self;
*****

***** HC\0.js
  637:              throw new TypeError('Bind must be called on a function');
  638:          var args;
  639:          var bound;
  640:      };
***** HC\ORIGINAL.JS
  677:              throw new TypeError('Bind must be called on a function');
  678:          var args = slice.call(arguments, 2);
  679:          var bound = function () {
  680:              return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
  681:          };
  682:          return bound;
  683:      };
*****

***** HC\0.js
  661:      _.bindAll = function (obj) {
  662:          var length = arguments.length;
  663:          if (length <= 1)
***** HC\ORIGINAL.JS
  704:      _.bindAll = function (obj) {
  705:          var i, length = arguments.length, key;
  706:          if (length <= 1)
*****

***** HC\0.js
  668:          }
  669:      };
***** HC\ORIGINAL.JS
  711:          }
  712:          return obj;
  713:      };
*****

***** HC\0.js
  698:      _.throttle = function (func, wait, options) {
  699:          var result;
  700:          var timeout = null;
***** HC\ORIGINAL.JS
  742:      _.throttle = function (func, wait, options) {
  743:          var context, args, result;
  744:          var timeout = null;
*****

***** HC\0.js
  707:              result = func.apply(context, args);
  708:          };
***** HC\ORIGINAL.JS
  751:              result = func.apply(context, args);
  752:              if (!timeout)
  753:                  context = args = null;
  754:          };
*****

***** HC\0.js
  716:              if (remaining <= 0 || remaining > wait) {
  717:                  previous = now;
***** HC\ORIGINAL.JS
  762:              if (remaining <= 0 || remaining > wait) {
  763:                  if (timeout) {
  764:                      clearTimeout(timeout);
  765:                      timeout = null;
  766:                  }
  767:                  previous = now;
*****

***** HC\0.js
  718:                  result = func.apply(context, args);
  719:              } else if (!timeout && options.trailing !== false) {
***** HC\ORIGINAL.JS
  768:                  result = func.apply(context, args);
  769:                  if (!timeout)
  770:                      context = args = null;
  771:              } else if (!timeout && options.trailing !== false) {
*****

***** HC\0.js
  729:      _.debounce = function (func, wait, immediate) {
  730:          var timeout, result;
  731:          var later = function () {
  732:              var last;
  733:              if (last < wait && last >= 0) {
  734:              } else {
***** HC\ORIGINAL.JS
  781:      _.debounce = function (func, wait, immediate) {
  782:          var timeout, args, context, timestamp, result;
  783:          var later = function () {
  784:              var last = _.now() - timestamp;
  785:              if (last < wait && last >= 0) {
  786:                  timeout = setTimeout(later, wait - last);
  787:              } else {
*****

***** HC\0.js
  737:                      result = func.apply(context, args);
  738:                  }
***** HC\ORIGINAL.JS
  790:                      result = func.apply(context, args);
  791:                      if (!timeout)
  792:                          context = args = null;
  793:                  }
*****

***** HC\0.js
  743:              args = arguments;
  744:              var callNow = immediate && !timeout;
***** HC\ORIGINAL.JS
  798:              args = arguments;
  799:              timestamp = _.now();
  800:              var callNow = immediate && !timeout;
*****

***** HC\0.js
  748:                  result = func.apply(context, args);
  749:              }
***** HC\ORIGINAL.JS
  804:                  result = func.apply(context, args);
  805:                  context = args = null;
  806:              }
*****

***** HC\0.js
  781:              if (--times < 1) {
  782:                  return func.apply(arguments);
  783:              }
***** HC\ORIGINAL.JS
  838:              if (--times < 1) {
  839:                  return func.apply(this, arguments);
  840:              }
*****

***** HC\0.js
  792:              }
  793:              return memo;
***** HC\ORIGINAL.JS
  849:              }
  850:              if (times <= 1)
  851:                  func = null;
  852:              return memo;
*****

***** HC\0.js
  801:      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  802:      var hasEnumBug = !{}.propertyIsEnumerable('toString');
  803:      var nonEnumerableProps;
  804:      // Retrieve the names of an object's own properties.
***** HC\ORIGINAL.JS
  860:      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  861:      var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  862:      var nonEnumerableProps = [
  863:          'valueOf',
  864:          'isPrototypeOf',
  865:          'toString',
  866:          'propertyIsEnumerable',
  867:          'hasOwnProperty',
  868:          'toLocaleString'
  869:      ];
  870:      function collectNonEnumProps(obj, keys) {
  871:          var nonEnumIdx = nonEnumerableProps.length;
  872:          var constructor = obj.constructor;
  873:          var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
  874:          // Constructor is a special case.
  875:          var prop = 'constructor';
  876:          if (_.has(obj, prop) && !_.contains(keys, prop))
  877:              keys.push(prop);
  878:          while (nonEnumIdx--) {
  879:              prop = nonEnumerableProps[nonEnumIdx];
  880:              if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
  881:                  keys.push(prop);
  882:              }
  883:          }
  884:      }
  885:      // Retrieve the names of an object's own properties.
*****

***** HC\0.js
  808:              return [];
  809:          var keys = [];
***** HC\ORIGINAL.JS
  889:              return [];
  890:          if (nativeKeys)
  891:              return nativeKeys(obj);
  892:          var keys = [];
*****

***** HC\0.js
  812:                  keys.push(key);
  813:          return keys;
***** HC\ORIGINAL.JS
  895:                  keys.push(key);
  896:          // Ahem, IE < 9.
  897:          if (hasEnumBug)
  898:              collectNonEnumProps(obj, keys);
  899:          return keys;
*****

***** HC\0.js
  821:              keys.push(key);
  822:          return keys;
***** HC\ORIGINAL.JS
  907:              keys.push(key);
  908:          // Ahem, IE < 9.
  909:          if (hasEnumBug)
  910:              collectNonEnumProps(obj, keys);
  911:          return keys;
*****

***** HC\0.js
  837:          iteratee = cb(iteratee, context);
  838:          var keys = _.keys(obj), length = keys.length, results = {};
  839:          for (var index = 0; index < length; index++) {
***** HC\ORIGINAL.JS
  926:          iteratee = cb(iteratee, context);
  927:          var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
  928:          for (var index = 0; index < length; index++) {
*****

***** HC\0.js
  884:          predicate = cb(predicate, context);
  885:          var keys = _.keys(obj);
  886:          for (var i = 0, length = keys.length; i < length; i++) {
***** HC\ORIGINAL.JS
  973:          predicate = cb(predicate, context);
  974:          var keys = _.keys(obj), key;
  975:          for (var i = 0, length = keys.length; i < length; i++) {
*****

***** HC\0.js
  893:      _.pick = function (object, oiteratee, context) {
  894:          var result = {}, obj = object;
  895:          if (obj == null)
***** HC\ORIGINAL.JS
  982:      _.pick = function (object, oiteratee, context) {
  983:          var result = {}, obj = object, iteratee, keys;
  984:          if (obj == null)
*****

***** HC\0.js
  965:      var eq = function (a, b, aStack, bStack) {
  966:          // A strict comparison is necessary because `null == undefined`.
***** HC\ORIGINAL.JS
 1054:      var eq = function (a, b, aStack, bStack) {
 1055:          // Identical objects are equal. `0 === -0`, but they aren't identical.
 1056:          // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
 1057:          if (a === b)
 1058:              return a !== 0 || 1 / a === 1 / b;
 1059:          // A strict comparison is necessary because `null == undefined`.
*****

***** HC\0.js
 1040:              // Deep compare objects.
 1041:              var keys = _.keys(a);
 1042:              length = keys.length;
***** HC\ORIGINAL.JS
 1133:              // Deep compare objects.
 1134:              var keys = _.keys(a), key;
 1135:              length = keys.length;
*****

***** HC\0.js
 1052:          }
 1053:          return true;
***** HC\ORIGINAL.JS
 1145:          }
 1146:          // Remove the first object from the stack of traversed objects.
 1147:          aStack.pop();
 1148:          bStack.pop();
 1149:          return true;
*****

***** HC\0.js
 1061:      _.isEmpty = function (obj) {
 1062:          if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
***** HC\ORIGINAL.JS
 1157:      _.isEmpty = function (obj) {
 1158:          if (obj == null)
 1159:              return true;
 1160:          if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
*****

***** HC\0.js
 1072:      _.isArray = nativeIsArray || function (obj) {
 1073:      };
***** HC\ORIGINAL.JS
 1170:      _.isArray = nativeIsArray || function (obj) {
 1171:          return toString.call(obj) === '[object Array]';
 1172:      };
*****

***** HC\0.js
 1092:      });
 1093:      // Is a given object a finite number?
***** HC\ORIGINAL.JS
 1191:      });
 1192:      // Define a fallback version of the method in browsers (ahem, IE < 9), where
 1193:      // there isn't any inspectable "Arguments" type.
 1194:      if (!_.isArguments(arguments)) {
 1195:          _.isArguments = function (obj) {
 1196:              return _.has(obj, 'callee');
 1197:          };
 1198:      }
 1199:      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
 1200:      // IE 11 (#1621), and in Safari 8 (#1929).
 1201:      if (typeof /./ != 'function' && typeof Int8Array != 'object') {
 1202:          _.isFunction = function (obj) {
 1203:              return typeof obj == 'function' || false;
 1204:          };
 1205:      }
 1206:      // Is a given object a finite number?
*****

***** HC\0.js
 1117:      };
 1118:      // Keep the identity function around for default iteratees.
***** HC\ORIGINAL.JS
 1230:      };
 1231:      // Utility Functions
 1232:      // -----------------
 1233:      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
 1234:      // previous owner. Returns a reference to the Underscore object.
 1235:      _.noConflict = function () {
 1236:          root._ = previousUnderscore;
 1237:          return this;
 1238:      };
 1239:      // Keep the identity function around for default iteratees.
*****

***** HC\0.js
 1147:      _.times = function (n, iteratee, context) {
 1148:          var accum = Array();
 1149:          iteratee = optimizeCb(iteratee, context, 1);
***** HC\ORIGINAL.JS
 1268:      _.times = function (n, iteratee, context) {
 1269:          var accum = Array(Math.max(0, n));
 1270:          iteratee = optimizeCb(iteratee, context, 1);
*****

***** HC\0.js
 1157:              max = min;
 1158:          }
***** HC\ORIGINAL.JS
 1278:              max = min;
 1279:              min = 0;
 1280:          }
*****

***** HC\0.js
 1162:      _.now = Date.now || function () {
 1163:      };
***** HC\ORIGINAL.JS
 1284:      _.now = Date.now || function () {
 1285:          return new Date().getTime();
 1286:      };
*****

***** HC\0.js
 1165:      var escapeMap = {
 1166:          '<': '&lt;',
***** HC\ORIGINAL.JS
 1288:      var escapeMap = {
 1289:          '&': '&amp;',
 1290:          '<': '&lt;',
*****

***** HC\0.js
 1220:          '\\': '\\',
 1221:          '\n': 'n',
***** HC\ORIGINAL.JS
 1344:          '\\': '\\',
 1345:          '\r': 'r',
 1346:          '\n': 'n',
*****

***** HC\0.js
 1233:      _.template = function (text, settings, oldSettings) {
 1234:          settings = _.defaults({}, settings, _.templateSettings);
***** HC\ORIGINAL.JS
 1358:      _.template = function (text, settings, oldSettings) {
 1359:          if (!settings && oldSettings)
 1360:              settings = oldSettings;
 1361:          settings = _.defaults({}, settings, _.templateSettings);
*****

***** HC\0.js
 1253:              }
 1254:          });
***** HC\ORIGINAL.JS
 1380:              }
 1381:              // Adobe VMs need the match returned to produce the correct offest.
 1382:              return match;
 1383:          });
*****

***** HC\0.js
 1271:          var argument = settings.variable || 'obj';
 1272:          return template;
***** HC\ORIGINAL.JS
 1400:          var argument = settings.variable || 'obj';
 1401:          template.source = 'function(' + argument + '){\n' + source + '}';
 1402:          return template;
*****

***** HC\0.js
 1315:              method.apply(obj, arguments);
 1316:              return result(this, obj);
***** HC\ORIGINAL.JS
 1445:              method.apply(obj, arguments);
 1446:              if ((name === 'shift' || name === 'splice') && obj.length === 0)
 1447:                  delete obj[0];
 1448:              return result(this, obj);
*****

***** HC\0.js
 1339:      };
 1340:  }.call());
***** HC\ORIGINAL.JS
 1471:      };
 1472:      // AMD registration happens at the end for compatibility with AMD loaders
 1473:      // that may not enforce next-turn semantics on modules. Even though general
 1474:      // practice for AMD registration is to be anonymous, underscore registers
 1475:      // as a named module because, like jQuery, it is a base library that is
 1476:      // popular enough to be bundled in a third party lib, but not be part of
 1477:      // an AMD load request. Those cases could generate an error when an
 1478:      // anonymous define() is called outside of a loader request.
 1479:      if (typeof define === 'function' && define.amd) {
 1480:          define('underscore', [], function () {
 1481:              return _;
 1482:          });
 1483:      }
 1484:  }.call(this));
*****

