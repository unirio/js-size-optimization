Comparando os arquivos HC\0.js e HC\ORIGINAL.JS
***** HC\0.js
    3:  (function (globalScope) {
    4:      /*
***** HC\ORIGINAL.JS
    3:  (function (globalScope) {
    4:      'use strict';
    5:      /*
*****

***** HC\0.js
  243:          pr = Ctor.precision;
  244:          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  245:          Ctor.precision = pr;
  246:          return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
***** HC\ORIGINAL.JS
  244:          pr = Ctor.precision;
  245:          rm = Ctor.rounding;
  246:          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  247:          Ctor.rounding = 1;
  248:          x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  249:          Ctor.precision = pr;
  250:          Ctor.rounding = rm;
  251:          return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
*****

***** HC\0.js
  268:          external = false;
  269:          // Math.cbrt underflow/overflow?
***** HC\ORIGINAL.JS
  273:          external = false;
  274:          // Initial estimate.
  275:          s = x.s * Math.pow(x.s * x, 1 / 3);
  276:          // Math.cbrt underflow/overflow?
*****

***** HC\0.js
  276:                  n += s == 1 || s == -2 ? '0' : '00';
  277:              if (s == 1 / 0) {
  278:              } else {
  279:              }
***** HC\ORIGINAL.JS
  283:                  n += s == 1 || s == -2 ? '0' : '00';
  284:              s = Math.pow(n, 1 / 3);
  285:              // Rarely, e may be one less than the result exponent value.
  286:              e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
  287:              if (s == 1 / 0) {
  288:                  n = '5e' + e;
  289:              } else {
  290:                  n = s.toExponential();
  291:                  n = n.slice(0, n.indexOf('e') + 1) + e;
  292:              }
*****

***** HC\0.js
  280:              r = new Ctor(n);
  281:          } else {
  282:          }
***** HC\ORIGINAL.JS
  293:              r = new Ctor(n);
  294:              r.s = x.s;
  295:          } else {
  296:              r = new Ctor(s.toString());
  297:          }
*****

***** HC\0.js
  289:              t3plusx = t3.plus(x);
  290:              // TODO? Replace with for-loop and checkRoundingDigits.
***** HC\ORIGINAL.JS
  304:              t3plusx = t3.plus(x);
  305:              r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
  306:              // TODO? Replace with for-loop and checkRoundingDigits.
*****

***** HC\0.js
  291:              if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
  292:                  // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
***** HC\ORIGINAL.JS
  307:              if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
  308:                  n = n.slice(sd - 3, sd + 1);
  309:                  // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
*****

***** HC\0.js
  297:                      if (!rep) {
  298:                          if (t.times(t).times(t).eq(x)) {
  299:                              break;
***** HC\ORIGINAL.JS
  314:                      if (!rep) {
  315:                          finalise(t, e + 1, 0);
  316:                          if (t.times(t).times(t).eq(x)) {
  317:                              r = t;
  318:                              break;
*****

***** HC\0.js
  301:                      }
  302:                  } else {
***** HC\ORIGINAL.JS
  320:                      }
  321:                      sd += 4;
  322:                      rep = 1;
  323:                  } else {
*****

***** HC\0.js
  305:                      if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
  306:                      }
***** HC\ORIGINAL.JS
  326:                      if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
  327:                          // Truncate to the first rounding digit.
  328:                          finalise(r, e + 1, 1);
  329:                          m = !r.times(r).times(r).eq(x);
  330:                      }
*****

***** HC\0.js
  310:          }
  311:          return finalise(r, e, Ctor.rounding, m);
***** HC\ORIGINAL.JS
  334:          }
  335:          external = true;
  336:          return finalise(r, e, Ctor.rounding, m);
*****

***** HC\0.js
  319:          if (d) {
  320:              if (w)
***** HC\ORIGINAL.JS
  344:          if (d) {
  345:              w = d.length - 1;
  346:              n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
  347:              // Subtract the number of trailing zeros of the last word.
  348:              w = d[w];
  349:              if (w)
*****

***** HC\0.js
  424:          pr = Ctor.precision;
  425:          // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
***** HC\ORIGINAL.JS
  453:          pr = Ctor.precision;
  454:          rm = Ctor.rounding;
  455:          Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  456:          Ctor.rounding = 1;
  457:          len = x.d.length;
  458:          // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
*****

***** HC\0.js
  429:          if (len < 32) {
  430:          } else {
  431:              n = '2.3283064365386962890625e-10';
***** HC\ORIGINAL.JS
  462:          if (len < 32) {
  463:              k = Math.ceil(len / 3);
  464:              n = Math.pow(4, -k).toString();
  465:          } else {
  466:              k = 16;
  467:              n = '2.3283064365386962890625e-10';
*****

***** HC\0.js
  432:          }
  433:          // Reverse argument reduction
***** HC\ORIGINAL.JS
  468:          }
  469:          x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  470:          // Reverse argument reduction
*****

***** HC\0.js
  435:          for (; i--;) {
  436:          }
***** HC\ORIGINAL.JS
  472:          for (; i--;) {
  473:              cosh2_x = x.times(x);
  474:              x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  475:          }
*****

***** HC\0.js
  473:          pr = Ctor.precision;
  474:          if (len < 3) {
  475:          } else {
  476:              k = k > 16 ? 16 : k | 0;
  477:              // Reverse argument reduction
***** HC\ORIGINAL.JS
  512:          pr = Ctor.precision;
  513:          rm = Ctor.rounding;
  514:          Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  515:          Ctor.rounding = 1;
  516:          len = x.d.length;
  517:          if (len < 3) {
  518:              x = taylorSeries(Ctor, 2, x, x, true);
  519:          } else {
  520:              // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
  521:              // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
  522:              // 3 multiplications and 1 addition
  523:              // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
  524:              // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
  525:              // 4 multiplications and 2 additions
  526:              // Estimate the optimum number of times to use the argument reduction.
  527:              k = 1.4 * Math.sqrt(len);
  528:              k = k > 16 ? 16 : k | 0;
  529:              x = x.times(Math.pow(5, -k));
  530:              x = taylorSeries(Ctor, 2, x, x, true);
  531:              // Reverse argument reduction
*****

***** HC\0.js
  479:              for (; k--;) {
  480:              }
***** HC\ORIGINAL.JS
  533:              for (; k--;) {
  534:                  sinh2_x = x.times(x);
  535:                  x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
  536:              }
*****

***** HC\0.js
  481:          }
  482:          return finalise(x, pr, rm, true);
***** HC\ORIGINAL.JS
  537:          }
  538:          Ctor.precision = pr;
  539:          Ctor.rounding = rm;
  540:          return finalise(x, pr, rm, true);
*****

***** HC\0.js
  506:          pr = Ctor.precision;
  507:          return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
***** HC\ORIGINAL.JS
  564:          pr = Ctor.precision;
  565:          rm = Ctor.rounding;
  566:          Ctor.precision = pr + 7;
  567:          Ctor.rounding = 1;
  568:          return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
*****

***** HC\0.js
  536:              return getPi(Ctor, pr + 4, rm).times(0.5);
  537:          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  538:          return halfPi.minus(x);
***** HC\ORIGINAL.JS
  597:              return getPi(Ctor, pr + 4, rm).times(0.5);
  598:          // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3
  599:          Ctor.precision = pr + 6;
  600:          Ctor.rounding = 1;
  601:          x = x.asin();
  602:          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  603:          Ctor.precision = pr;
  604:          Ctor.rounding = rm;
  605:          return halfPi.minus(x);
*****

***** HC\0.js
  565:          pr = Ctor.precision;
  566:          return x.ln();
***** HC\ORIGINAL.JS
  632:          pr = Ctor.precision;
  633:          rm = Ctor.rounding;
  634:          Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  635:          Ctor.rounding = 1;
  636:          external = false;
  637:          x = x.times(x).minus(1).sqrt().plus(x);
  638:          external = true;
  639:          Ctor.precision = pr;
  640:          Ctor.rounding = rm;
  641:          return x.ln();
*****

***** HC\0.js
  588:          pr = Ctor.precision;
  589:          return x.ln();
***** HC\ORIGINAL.JS
  663:          pr = Ctor.precision;
  664:          rm = Ctor.rounding;
  665:          Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  666:          Ctor.rounding = 1;
  667:          external = false;
  668:          x = x.times(x).plus(1).sqrt().plus(x);
  669:          external = true;
  670:          Ctor.precision = pr;
  671:          Ctor.rounding = rm;
  672:          return x.ln();
*****

***** HC\0.js
  616:          pr = Ctor.precision;
  617:          xsd = x.sd();
***** HC\ORIGINAL.JS
  699:          pr = Ctor.precision;
  700:          rm = Ctor.rounding;
  701:          xsd = x.sd();
*****

***** HC\0.js
  620:          Ctor.precision = wpr = xsd - x.e;
  621:          return x.times(0.5);
***** HC\ORIGINAL.JS
  704:          Ctor.precision = wpr = xsd - x.e;
  705:          x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  706:          Ctor.precision = pr + 4;
  707:          Ctor.rounding = 1;
  708:          x = x.ln();
  709:          Ctor.precision = pr;
  710:          Ctor.rounding = rm;
  711:          return x.times(0.5);
*****

***** HC\0.js
  647:              return new Ctor(x);
  648:          if (k !== -1) {
***** HC\ORIGINAL.JS
  737:              return new Ctor(x);
  738:          k = x.abs().cmp(1);
  739:          pr = Ctor.precision;
  740:          rm = Ctor.rounding;
  741:          if (k !== -1) {
*****

***** HC\0.js
  650:              if (k === 0) {
  651:                  return halfPi;
***** HC\ORIGINAL.JS
  743:              if (k === 0) {
  744:                  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  745:                  halfPi.s = x.s;
  746:                  return halfPi;
*****

***** HC\0.js
  655:          }
  656:          return x.times(2);
***** HC\ORIGINAL.JS
  750:          }
  751:          // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6
  752:          Ctor.precision = pr + 6;
  753:          Ctor.rounding = 1;
  754:          x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  755:          Ctor.precision = pr;
  756:          Ctor.rounding = rm;
  757:          return x.times(2);
*****

***** HC\0.js
  682:                  r = getPi(Ctor, pr + 4, rm).times(0.5);
  683:                  return r;
***** HC\ORIGINAL.JS
  783:                  r = getPi(Ctor, pr + 4, rm).times(0.5);
  784:                  r.s = x.s;
  785:                  return r;
*****

***** HC\0.js
  688:              r = getPi(Ctor, pr + 4, rm).times(0.25);
  689:              return r;
***** HC\ORIGINAL.JS
  790:              r = getPi(Ctor, pr + 4, rm).times(0.25);
  791:              r.s = x.s;
  792:              return r;
*****

***** HC\0.js
  691:          Ctor.precision = wpr = pr + 10;
  692:          // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
***** HC\ORIGINAL.JS
  794:          Ctor.precision = wpr = pr + 10;
  795:          Ctor.rounding = 1;
  796:          // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
*****

***** HC\0.js
  706:          for (; i !== -1;) {
  707:              t = r.minus(px.div(n += 2));
***** HC\ORIGINAL.JS
  810:          for (; i !== -1;) {
  811:              px = px.times(x2);
  812:              t = r.minus(px.div(n += 2));
*****

***** HC\0.js
  714:              r = r.times(2 << k - 1);
  715:          return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
***** HC\ORIGINAL.JS
  819:              r = r.times(2 << k - 1);
  820:          external = true;
  821:          return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
*****

***** HC\0.js
  807:          if (base == null) {
  808:              isBase10 = true;
***** HC\ORIGINAL.JS
  913:          if (base == null) {
  914:              base = new Ctor(10);
  915:              isBase10 = true;
*****

***** HC\0.js
  809:          } else {
  810:              // Return NaN if base is negative, or non-finite, or is 0 or 1.
***** HC\ORIGINAL.JS
  916:          } else {
  917:              base = new Ctor(base);
  918:              d = base.d;
  919:              // Return NaN if base is negative, or non-finite, or is 0 or 1.
*****

***** HC\0.js
  812:                  return new Ctor(NaN);
  813:          }
  814:          // Is arg negative, non-finite, 0 or 1?
***** HC\ORIGINAL.JS
  921:                  return new Ctor(NaN);
  922:              isBase10 = base.eq(10);
  923:          }
  924:          d = arg.d;
  925:          // Is arg negative, non-finite, 0 or 1?
*****

***** HC\0.js
  821:              if (d.length > 1) {
  822:              } else {
***** HC\ORIGINAL.JS
  932:              if (d.length > 1) {
  933:                  inf = true;
  934:              } else {
*****

***** HC\0.js
  824:                      k /= 10;
  825:              }
***** HC\ORIGINAL.JS
  936:                      k /= 10;
  937:                  inf = k !== 1;
  938:              }
*****

***** HC\0.js
  826:          }
  827:          // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
***** HC\ORIGINAL.JS
  939:          }
  940:          external = false;
  941:          sd = pr + guard;
  942:          num = naturalLogarithm(arg, sd);
  943:          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  944:          // The result will have 5 rounding digits.
  945:          r = divide(num, denominator, sd, 1);
  946:          // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
*****

***** HC\0.js
  842:              do {
  843:                  if (!inf) {
***** HC\ORIGINAL.JS
  961:              do {
  962:                  sd += 10;
  963:                  num = naturalLogarithm(arg, sd);
  964:                  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  965:                  r = divide(num, denominator, sd, 1);
  966:                  if (!inf) {
*****

***** HC\0.js
  845:                      if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
  846:                      }
***** HC\ORIGINAL.JS
  968:                      if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
  969:                          r = finalise(r, pr + 1, 0);
  970:                      }
*****

***** HC\0.js
  850:          }
  851:          return finalise(r, pr, rm);
***** HC\ORIGINAL.JS
  974:          }
  975:          external = true;
  976:          return finalise(r, pr, rm);
*****

***** HC\0.js
  905:                                 // Return NaN if both are ±Infinity with the same sign.
  906:              return y;
***** HC\ORIGINAL.JS
 1030:                                 // Return NaN if both are ±Infinity with the same sign.
 1031:              else
 1032:                  y = new Ctor(y.d || x.s !== y.s ? x : NaN);
 1033:              return y;
*****

***** HC\0.js
  909:          if (x.s != y.s) {
  910:              return x.plus(y);
***** HC\ORIGINAL.JS
 1036:          if (x.s != y.s) {
 1037:              y.s = -y.s;
 1038:              return x.plus(y);
*****

***** HC\0.js
  914:          pr = Ctor.precision;
  915:          // If either is zero...
***** HC\ORIGINAL.JS
 1042:          pr = Ctor.precision;
 1043:          rm = Ctor.rounding;
 1044:          // If either is zero...
*****

***** HC\0.js
  950:                  k = i;
  951:              }
  952:              for (i = k; i--;)
***** HC\ORIGINAL.JS
 1079:                  k = i;
 1080:                  d.length = 1;
 1081:              }
 1082:              // Prepend zeros to equalise exponents.
 1083:              d.reverse();
 1084:              for (i = k; i--;)
*****

***** HC\0.js
  967:              }
  968:          }
***** HC\ORIGINAL.JS
 1099:              }
 1100:              k = 0;
 1101:          }
*****

***** HC\0.js
  972:              yd = d;
  973:          }
  974:          // Append zeros to `xd` if shorter.
***** HC\ORIGINAL.JS
 1105:              yd = d;
 1106:              y.s = -y.s;
 1107:          }
 1108:          len = xd.length;
 1109:          // Append zeros to `xd` if shorter.
*****

***** HC\0.js
 1026:          var q, x = this, Ctor = x.constructor;
 1027:          // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
***** HC\ORIGINAL.JS
 1161:          var q, x = this, Ctor = x.constructor;
 1162:          y = new Ctor(y);
 1163:          // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
*****

***** HC\0.js
 1033:          }
 1034:          if (Ctor.modulo == 9) {
 1035:          } else {
***** HC\ORIGINAL.JS
 1169:          }
 1170:          // Prevent rounding of intermediate calculations.
 1171:          external = false;
 1172:          if (Ctor.modulo == 9) {
 1173:              // Euclidian division: q = sign(y) * floor(x / abs(y))
 1174:              // result = x - q * y    where  0 <= result < abs(y)
 1175:              q = divide(x, y.abs(), 0, 3, 1);
 1176:              q.s *= y.s;
 1177:          } else {
*****

***** HC\0.js
 1037:          }
 1038:          return x.minus(q);
***** HC\ORIGINAL.JS
 1179:          }
 1180:          q = q.times(y);
 1181:          external = true;
 1182:          return x.minus(q);
*****

***** HC\0.js
 1063:          var x = new this.constructor(this);
 1064:          return finalise(x);
***** HC\ORIGINAL.JS
 1207:          var x = new this.constructor(this);
 1208:          x.s = -x.s;
 1209:          return finalise(x);
*****

***** HC\0.js
 1108:          yd = y.d;
 1109:          // If either is zero...
***** HC\ORIGINAL.JS
 1253:          yd = y.d;
 1254:          pr = Ctor.precision;
 1255:          rm = Ctor.rounding;
 1256:          // If either is zero...
*****

***** HC\0.js
 1135:              k = Math.ceil(pr / LOG_BASE);
 1136:              if (i > len) {
***** HC\ORIGINAL.JS
 1282:              k = Math.ceil(pr / LOG_BASE);
 1283:              len = k > len ? k + 1 : len + 1;
 1284:              if (i > len) {
*****

***** HC\0.js
 1137:                  i = len;
 1138:              }
***** HC\ORIGINAL.JS
 1285:                  i = len;
 1286:                  d.length = 1;
 1287:              }
*****

***** HC\0.js
 1185:          } else {
 1186:          }
***** HC\ORIGINAL.JS
 1334:          } else {
 1335:              k = NaN;
 1336:          }
*****

***** HC\0.js
 1219:          pr = Ctor.precision;
 1220:          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
 1221:          return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
***** HC\ORIGINAL.JS
 1369:          pr = Ctor.precision;
 1370:          rm = Ctor.rounding;
 1371:          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
 1372:          Ctor.rounding = 1;
 1373:          x = sine(Ctor, toLessThanHalfPi(Ctor, x));
 1374:          Ctor.precision = pr;
 1375:          Ctor.rounding = rm;
 1376:          return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
*****

***** HC\0.js
 1252:              if (s == 1 / 0) {
 1253:              } else {
***** HC\ORIGINAL.JS
 1407:              if (s == 1 / 0) {
 1408:                  n = '1e' + e;
 1409:              } else {
*****

***** HC\0.js
 1264:              t = r;
 1265:              // TODO? Replace with for-loop and checkRoundingDigits.
***** HC\ORIGINAL.JS
 1420:              t = r;
 1421:              r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
 1422:              // TODO? Replace with for-loop and checkRoundingDigits.
*****

***** HC\0.js
 1266:              if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
 1267:                  // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
***** HC\ORIGINAL.JS
 1423:              if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
 1424:                  n = n.slice(sd - 3, sd + 1);
 1425:                  // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
*****

***** HC\0.js
 1272:                      if (!rep) {
 1273:                          if (t.times(t).eq(x)) {
 1274:                              break;
***** HC\ORIGINAL.JS
 1430:                      if (!rep) {
 1431:                          finalise(t, e + 1, 0);
 1432:                          if (t.times(t).eq(x)) {
 1433:                              r = t;
 1434:                              break;
*****

***** HC\0.js
 1276:                      }
 1277:                  } else {
***** HC\ORIGINAL.JS
 1436:                      }
 1437:                      sd += 4;
 1438:                      rep = 1;
 1439:                  } else {
*****

***** HC\0.js
 1280:                      if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
 1281:                      }
***** HC\ORIGINAL.JS
 1442:                      if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
 1443:                          // Truncate to the first rounding digit.
 1444:                          finalise(r, e + 1, 1);
 1445:                          m = !r.times(r).eq(x);
 1446:                      }
*****

***** HC\0.js
 1285:          }
 1286:          return finalise(r, e, Ctor.rounding, m);
***** HC\ORIGINAL.JS
 1450:          }
 1451:          external = true;
 1452:          return finalise(r, e, Ctor.rounding, m);
*****

***** HC\0.js
 1307:          pr = Ctor.precision;
 1308:          return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
***** HC\ORIGINAL.JS
 1473:          pr = Ctor.precision;
 1474:          rm = Ctor.rounding;
 1475:          Ctor.precision = pr + 10;
 1476:          Ctor.rounding = 1;
 1477:          x = x.sin();
 1478:          x.s = 1;
 1479:          x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
 1480:          Ctor.precision = pr;
 1481:          Ctor.rounding = rm;
 1482:          return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
*****

***** HC\0.js
 1350:              rL = xdL;
 1351:          }
***** HC\ORIGINAL.JS
 1524:              rL = xdL;
 1525:              xdL = ydL;
 1526:              ydL = rL;
 1527:          }
*****

***** HC\0.js
 1462:              y = finalise(new Ctor(x), dp + x.e + 1, rm);
 1463:          }
***** HC\ORIGINAL.JS
 1638:              y = finalise(new Ctor(x), dp + x.e + 1, rm);
 1639:              str = finiteToString(y, false, dp + y.e + 1);
 1640:          }
*****

***** HC\0.js
 1500:          pr = Ctor.precision;
 1501:          for (;;) {
***** HC\ORIGINAL.JS
 1677:          pr = Ctor.precision;
 1678:          Ctor.precision = e = xd.length * LOG_BASE * 2;
 1679:          for (;;) {
*****

***** HC\0.js
 1507:              d1 = d2;
 1508:              n1 = n0.plus(q.times(d2));
***** HC\ORIGINAL.JS
 1685:              d1 = d2;
 1686:              d2 = n1;
 1687:              n1 = n0.plus(q.times(d2));
*****

***** HC\0.js
 1525:          ];
 1526:          external = true;
***** HC\ORIGINAL.JS
 1704:          ];
 1705:          Ctor.precision = pr;
 1706:          external = true;
*****

***** HC\0.js
 1565:          var x = this, Ctor = x.constructor;
 1566:          if (y == null) {
***** HC\ORIGINAL.JS
 1745:          var x = this, Ctor = x.constructor;
 1746:          x = new Ctor(x);
 1747:          if (y == null) {
*****

***** HC\0.js
 1596:              x = divide(x, y, 0, rm, 1).times(y);
 1597:              finalise(x);    // If y is zero, return zero with the sign of x.
***** HC\ORIGINAL.JS
 1777:              x = divide(x, y, 0, rm, 1).times(y);
 1778:              external = true;
 1779:              finalise(x);    // If y is zero, return zero with the sign of x.
*****

***** HC\0.js
 1729:                  e = pr + 10;
 1730:                  // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
***** HC\ORIGINAL.JS
 1911:                  e = pr + 10;
 1912:                  // Truncate to the increased precision plus five rounding digits.
 1913:                  r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
 1914:                  // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
*****

***** HC\0.js
 1731:                  if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
 1732:                  }
***** HC\ORIGINAL.JS
 1915:                  if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
 1916:                      r = finalise(r, pr + 1, 0);
 1917:                  }
*****

***** HC\0.js
 1753:          if (sd === void 0) {
 1754:          } else {
***** HC\ORIGINAL.JS
 1938:          if (sd === void 0) {
 1939:              str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
 1940:          } else {
*****

***** HC\0.js
 1781:          if (sd === void 0) {
 1782:          } else {
 1783:              if (rm === void 0)
***** HC\ORIGINAL.JS
 1967:          if (sd === void 0) {
 1968:              sd = Ctor.precision;
 1969:              rm = Ctor.rounding;
 1970:          } else {
 1971:              checkInt32(sd, 1, MAX_DIGITS);
 1972:              if (rm === void 0)
*****

***** HC\0.js
 1877:                  ws = d[i] + '';
 1878:                  if (k)
***** HC\ORIGINAL.JS
 2066:                  ws = d[i] + '';
 2067:                  k = LOG_BASE - ws.length;
 2068:                  if (k)
*****

***** HC\0.js
 1883:              ws = w + '';
 1884:              if (k)
***** HC\ORIGINAL.JS
 2073:              ws = w + '';
 2074:              k = LOG_BASE - ws.length;
 2075:              if (k)
*****

***** HC\0.js
 1940:                      rd = rd / 10 | 0;
 1941:              } else {
***** HC\ORIGINAL.JS
 2131:                      rd = rd / 10 | 0;
 2132:                  r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
 2133:              } else {
*****

***** HC\0.js
 1982:              k = 16;
 1983:          }
***** HC\ORIGINAL.JS
 2174:              k = 16;
 2175:              y = '2.3283064365386962890625e-10';
 2176:          }
*****

***** HC\0.js
 2106:                      yz.unshift(0);
 2107:                      if (yd[1] >= base / 2)
***** HC\ORIGINAL.JS
 2299:                      yz.unshift(0);
 2300:                      yd0 = yd[0];
 2301:                      if (yd[1] >= base / 2)
*****

***** HC\0.js
 2118:                                  rem0 = rem0 * base + (rem[1] || 0);
 2119:                              //  Algorithm:
***** HC\ORIGINAL.JS
 2312:                                  rem0 = rem0 * base + (rem[1] || 0);
 2313:                              // k will be how many times the divisor goes into the current remainder.
 2314:                              k = rem0 / yd0 | 0;
 2315:                              //  Algorithm:
*****

***** HC\0.js
 2128:                                      k = base - 1;
 2129:                                  remL = rem.length;
 2130:                                  // product > remainder.
***** HC\ORIGINAL.JS
 2324:                                      k = base - 1;
 2325:                                  // product = divisor * trial digit.
 2326:                                  prod = multiplyInteger(yd, k, base);
 2327:                                  prodL = prod.length;
 2328:                                  remL = rem.length;
 2329:                                  // Compare product and remainder.
 2330:                                  cmp = compare(prod, rem, prodL, remL);
 2331:                                  // product > remainder.
*****

***** HC\0.js
 2131:                                  if (cmp == 1) {
 2132:                                  }
***** HC\ORIGINAL.JS
 2332:                                  if (cmp == 1) {
 2333:                                      k--;
 2334:                                      // Subtract divisor from product.
 2335:                                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
 2336:                                  }
*****

***** HC\0.js
 2140:                              }
 2141:                              if (prodL < remL)
***** HC\ORIGINAL.JS
 2344:                              }
 2345:                              prodL = prod.length;
 2346:                              if (prodL < remL)
*****

***** HC\0.js
 2142:                                  prod.unshift(0);
 2143:                              // If product was < previous remainder.
***** HC\ORIGINAL.JS
 2347:                                  prod.unshift(0);
 2348:                              // Subtract product from remainder.
 2349:                              subtract(rem, prod, remL, base);
 2350:                              // If product was < previous remainder.
*****

***** HC\0.js
 2144:                              if (cmp == -1) {
 2145:                                  // If divisor < new remainder, subtract divisor from remainder.
***** HC\ORIGINAL.JS
 2351:                              if (cmp == -1) {
 2352:                                  remL = rem.length;
 2353:                                  // Compare divisor and new remainder.
 2354:                                  cmp = compare(yd, rem, yL, remL);
 2355:                                  // If divisor < new remainder, subtract divisor from remainder.
*****

***** HC\0.js
 2146:                                  if (cmp < 1) {
 2147:                                      // Subtract divisor from remainder.
***** HC\ORIGINAL.JS
 2356:                                  if (cmp < 1) {
 2357:                                      k++;
 2358:                                      // Subtract divisor from remainder.
*****

***** HC\0.js
 2150:                              }
 2151:                          } else if (cmp === 0) {
***** HC\ORIGINAL.JS
 2361:                              }
 2362:                              remL = rem.length;
 2363:                          } else if (cmp === 0) {
*****

***** HC\0.js
 2173:              if (logBase == 1) {
 2174:              } else {
***** HC\ORIGINAL.JS
 2385:              if (logBase == 1) {
 2386:                  q.e = e;
 2387:                  inexact = more;
 2388:              } else {
*****

***** HC\0.js
 2209:                  if (i < 0) {
 2210:                      w = xd[xdi = 0];
***** HC\ORIGINAL.JS
 2423:                  if (i < 0) {
 2424:                      i += LOG_BASE;
 2425:                      j = sd;
 2426:                      w = xd[xdi = 0];
*****

***** HC\0.js
 2220:                                  xd.push(0);
 2221:                              j = i - LOG_BASE + 1;
***** HC\ORIGINAL.JS
 2436:                                  xd.push(0);
 2437:                              w = rd = 0;
 2438:                              digits = 1;
 2439:                              i %= LOG_BASE;
 2440:                              j = i - LOG_BASE + 1;
*****

***** HC\0.js
 2231:                          i %= LOG_BASE;
 2232:                          // Get the rounding digit at index j of w.
***** HC\ORIGINAL.JS
 2450:                          i %= LOG_BASE;
 2451:                          // Get the index of rd within w, adjusted for leading zeros.
 2452:                          // The number of leading zeros of w is given by LOG_BASE - digits.
 2453:                          j = i - LOG_BASE + digits;
 2454:                          // Get the rounding digit at index j of w.
*****

***** HC\0.js
 2246:                      if (roundUp) {
 2247:                          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
***** HC\ORIGINAL.JS
 2468:                      if (roundUp) {
 2469:                          // Convert sd to decimal places.
 2470:                          sd -= x.e + 1;
 2471:                          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
*****

***** HC\0.js
 2258:                      xd.length = xdi;
 2259:                      xdi--;
***** HC\ORIGINAL.JS
 2482:                      xd.length = xdi;
 2483:                      k = 1;
 2484:                      xdi--;
*****

***** HC\0.js
 2261:                      xd.length = xdi + 1;
 2262:                      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
***** HC\ORIGINAL.JS
 2486:                      xd.length = xdi + 1;
 2487:                      k = mathpow(10, LOG_BASE - i);
 2488:                      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
*****

***** HC\0.js
 2277:                              if (i != k) {
 2278:                                  if (xd[0] == BASE)
***** HC\ORIGINAL.JS
 2503:                              if (i != k) {
 2504:                                  x.e++;
 2505:                                  if (xd[0] == BASE)
*****

***** HC\0.js
 2282:                          } else {
 2283:                              if (xd[xdi] != BASE)
***** HC\ORIGINAL.JS
 2509:                          } else {
 2510:                              xd[xdi] += k;
 2511:                              if (xd[xdi] != BASE)
*****

***** HC\0.js
 2284:                                  break;
 2285:                          }
***** HC\ORIGINAL.JS
 2512:                                  break;
 2513:                              xd[xdi--] = 0;
 2514:                              k = 1;
 2515:                          }
*****

***** HC\0.js
 2311:              if (sd && (k = sd - len) > 0) {
 2312:              } else if (len > 1) {
 2313:              }
***** HC\ORIGINAL.JS
 2541:              if (sd && (k = sd - len) > 0) {
 2542:                  str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
 2543:              } else if (len > 1) {
 2544:                  str = str.charAt(0) + '.' + str.slice(1);
 2545:              }
*****

***** HC\0.js
 2388:              k = Math.ceil(pr / LOG_BASE + 4);
 2389:          for (;;) {
***** HC\ORIGINAL.JS
 2620:              k = Math.ceil(pr / LOG_BASE + 4);
 2621:          external = false;
 2622:          for (;;) {
*****

***** HC\0.js
 2390:              if (n % 2) {
 2391:                  if (truncate(r.d, k))
***** HC\ORIGINAL.JS
 2623:              if (n % 2) {
 2624:                  r = r.times(x);
 2625:                  if (truncate(r.d, k))
*****

***** HC\0.js
 2395:              if (n === 0) {
 2396:                  if (isTruncated && r.d[n] === 0)
***** HC\ORIGINAL.JS
 2629:              if (n === 0) {
 2630:                  // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
 2631:                  n = r.d.length - 1;
 2632:                  if (isTruncated && r.d[n] === 0)
*****

***** HC\0.js
 2399:              }
 2400:          }
***** HC\ORIGINAL.JS
 2635:              }
 2636:              x = x.times(x);
 2637:              truncate(x.d, k);
 2638:          }
*****

***** HC\0.js
 2414:              if (!y.s) {
 2415:                  break;
***** HC\ORIGINAL.JS
 2652:              if (!y.s) {
 2653:                  x = y;
 2654:                  break;
*****

***** HC\0.js
 2416:              } else if (x[ltgt](y)) {
 2417:              }
***** HC\ORIGINAL.JS
 2655:              } else if (x[ltgt](y)) {
 2656:                  x = y;
 2657:              }
*****

***** HC\0.js
 2480:              denominator = denominator.times(++i);
 2481:              if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
 2482:                  while (j--)
***** HC\ORIGINAL.JS
 2720:              denominator = denominator.times(++i);
 2721:              t = sum.plus(divide(pow, denominator, wpr, 1));
 2722:              if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
 2723:                  j = k;
 2724:                  while (j--)
*****

***** HC\0.js
 2491:                          Ctor.precision = wpr += 10;
 2492:                      } else {
***** HC\ORIGINAL.JS
 2733:                          Ctor.precision = wpr += 10;
 2734:                          denominator = pow = t = new Ctor(1);
 2735:                          i = 0;
 2736:                          rep++;
 2737:                      } else {
*****

***** HC\0.js
 2525:          if (sd == null) {
 2526:              wpr = pr;
***** HC\ORIGINAL.JS
 2770:          if (sd == null) {
 2771:              external = false;
 2772:              wpr = pr;
*****

